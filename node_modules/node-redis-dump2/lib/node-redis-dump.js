'use strict';
/**
 * Redis dump main file.
 *
 * @author Dmitriy Yurchenko <evildev@evildev.ru>
 * @author Stefan Seide <account-github@seide.st>
 */

const async = require('async');
const _ = require('underscore');

/**
 * Redis dump class.
 *
 * @param {Object} params init params.
 * @constructor
 */
class RedisDump {

  constructor(params) {
    this.client = null;
    this.params = typeof params === 'object' ? params : {};
  }

  /**
   * @return {String} version of library.
   */
  getVersion() {
    return require('../package.json').version;
  }

  /**
   * @return {Object} redis client.
   */
  getClient() {
    if (!this.client) {
      // duplicate client and save local to not block external usage or create chaos by selecting different db
      if (this.params.client && typeof this.params.client.duplicate === 'function') {
        this.client = this.params.client.duplicate();
      }
    }
    // fallback to param.client when no new connection possible ("redis" instead of "ioredis"?)
    return this.client || this.params.client;
  }

  /**
   * @return {Object} initialize parameters.
   */
  getConnectParams() {
    return this.params;
  }

  /**
   * Connect to redis server if not set client during initialize.
   * The paras object from Import/Export initializations is passed through to ioredis
   * to create a new client connection
   *
   * @return {Boolean} true if success connect.
   */
  connect() {
    if (!this.client && !(this.params && this.params.client)) {
      const Redis = require('ioredis');
      this.client = new Redis(this.params);
    }
    return !!this.client;
  }

  /**
   * Disconnect from redis server if library created its own client.
   * External Clients set initialisation are ignored and not disconnected.
   *
   * @return {Boolean} true if success on disconnect.
   */
  disconnect() {
    if (this.client) {
      this.client.disconnect();
      this.client = null;
      return true;
    }
    return !this.client;
  }

  selectDb(db, callback) {
    if (_.isNumber(db)) {
      this.getClient().select(db, (err, status) => {
        if (typeof callback === "function") callback()
      });
    }
    else {
      if (typeof callback === "function") callback();
    }
  }


  /**
   * Read key.
   *
   * @param {String} key name of the key to read
   * @param {String} type data type of key to read
   * @param {Function} rkCallback callback function
   */
  _readKey(key, type, rkCallback) {
    const params = [key];
    const command = {
      set: 'smembers',
      zset: 'zrange',
      list: 'lrange',
      hash: 'hgetall'
    }[type] || 'get';
    const that = this;

    if (command.indexOf('range') !== -1) {
      params.push(0);
      params.push(-1);
    }

    params.push(function(err, values) {
      if (err) {
        rkCallback(err);
        return;
      }

      switch (type) {
        case 'zset':
          that._readScores(key, values, function(errRS, scores) {
            rkCallback(null, _.zip(scores, values));
          });
          break;

        default:
          rkCallback(null, values);
          break;
      }
    });

    this.getClient()[command].apply(this.getClient(), params);
  }

  /**
   * Read scores by values.
   *
   * @param {string} key redis key to read score from
   * @param {Array} values list of all members for this redis key where scores shall be read
   * @param {Function} rsCallback callback function
   */
  _readScores(key, values, rsCallback) {
    const result = [];
    const client = this.getClient();
    const getScoreFunction = function(value, index, cb) {
      client.zscore(key, value, function(err, score) {
        result[index] = score;
        cb(err);
      });
    };

    async.eachOfLimit(values, 10, getScoreFunction, function(err) {
      if (err) {
        rsCallback(err);
      }
      else {
        rsCallback(null, result);
      }
    });
  }
}

/**
 * Make redis dump.
 *
 * @param {Object} params export configuration parameter
 */
RedisDump.prototype.export = function(params) {
  'use strict';

  /**
   * @return {Object} export params
   */
  this.getExportParams = function() {
    return params;
  };

  /**
   * Read key callback by type.
   * @param {string} key redis key to query
   * @param {object} data result data object to modify
   * @param {function} callback function to call on completion with params (error, result)
   */
  this._getForTypeCallback = function(key, data, callback) {
    const that = this;
    switch (this.getExportParams().type) {
      // Export as redis type.
      case 'redis':
        return function(err, type) {
          const type2PrintSetCommand = {
            string: 'SET',
            set: 'SADD',
            zset: 'ZADD',
            list: 'RPUSH',
            hash: 'HSET'
          };

          if (!data) {
            data = '';
          }

          that._readKey(key, type, function(errRK, value) {
            if (errRK) {
              callback(errRK);
              return;
            }

            const command = type2PrintSetCommand[type];
            key = key.trim();

            switch (type) {
              case 'set':
                _.each(value, function(item) {
                  data += command + ' "' + key + '" "' + item + '"\n';
                });
                break;

              case 'zset':
                _.each(value, function(item) {
                  data += command + ' "' + key + '" ' + item[0] + ' "' + item[1] + '"\n';
                });
                break;

              case 'hash':
                _.each(_.pairs(value), function(item) {
                  data += command + ' "' + key + '" "' + item[0] + '" "' + item[1] + '"\n';
                });
                break;

              default:
                data += command + ' "' + key + '" "' + value + '"\n';
                break;
            }

            callback(null, data);
          });
        };

      // Export as json type.
      case 'json':
        return function(err, type) {
          if (!data) {
            data = {};
          }

          that._readKey(key, type, function(errRK, value) {
            if (errRK) {
              callback(errRK);
              return;
            }

            switch (type) {
              case 'zset':
                const withoutScores = [];
                _.each(value, function(item) {
                  withoutScores.push(item[1]);
                });
                value = withoutScores;
                break;
            }

            data[key.trim()] = value;
            callback(null, data);
          });
        };
    }
  };

  async.waterfall([
    /**
     * Select DB if need.
     * @param {function} callback - async waterfall callback
     */
    function(callback) {
      this.selectDb(this.getExportParams().db, callback);
    }.bind(this),

    /**
     * Get all keys from this db.
     * @param {function} callback - async waterfall callback
     */
    function(callback) {
      const pattern = this.getExportParams().keyPrefix ? this.getExportParams().keyPrefix + '*' : '*';
      this.getClient().keys(pattern, callback);
    }.bind(this),

    /**
     * Read all the keys.
     *
     * @param {Array} keys
     * @param {function} callback - async waterfall callback
     */
    function(keys, callback) {
      let exportData;
      if (!Array.isArray(keys) || keys.length === 0) {
        callback(null, exportData);
        return;
      }

      /**
       * Read keys recursive.
       */
      const readKeysRecursive = function(err, data) {
        if (err) {
          callback(err);
          return;
        }

        if (data) {
          exportData = data;
        }

        if (!keys.length) {
          callback(null, exportData);
          return;
        }

        const key = keys.pop();

        this.getClient().type(key, this._getForTypeCallback.call(this, key, exportData, readKeysRecursive));
      }.bind(this);


      if (this.getExportParams().type === 'dump-base64') {
        // no special handling for different redis data types needed, just dump/restore all keys
        this.dumpAsBase64(keys, callback);
      }
      else {
        // need to fetch type for every key to determine proper handling
        readKeysRecursive();
      }
    }.bind(this)
  ], function(err, data) {
    if (!_.isFunction(params.callback)) {
      params.callback = function() {
        // intentionally empty
      };
    }

    params.callback(err, data);
  });

  this.dumpAsBase64 = function(keys, callback) {
    const client = this.getClient();
    const getDumpAsync = function(key) {
      return new Promise((resolve, reject) => {
        client.dumpBuffer(key, function(err, value) {
          if (err) reject(err);
          else resolve(value.toString('base64'));
        });
      });
    };
    const getTTLAsync = function(key) {
      return new Promise((resolve, reject) => {
        client.ttl(key, function(err, ttl) {
          if (err) reject(err);
          else resolve(ttl);
        });
      });
    };
    Promise.allSettled(keys.map(async function(key) {
      try {
        const data = await Promise.all([getTTLAsync(key), getDumpAsync(key)]);
        return {
          key: key,
          ttl: data[0] < 0 ? 0 : data[0],
          data: data[1]
        };
      }
      catch (e) {
        return ""
      }
    })).then(exported => {
      callback(null, exported.reduce((acc, cur, idx) => {
        if (cur.status === "fulfilled" && cur.value.key) {
          return `${acc}${idx > 0 ? '\n' : ''}RESTOREB64 "${cur.value.key}" ${cur.value.ttl} "${cur.value.data}"`
        }
        else {
          return acc;
        }
      }, ""));
    })
  }
};

/**
 * Import redis data.
 *
 * @param {object} params - import parameter
 */
RedisDump.prototype.import = function(params) {
  'use strict';

  // Import report.
  const report = {
    inserted: 0,
    errors: 0,
    errorMsgs: []
  };

  /**
   * @return {Object} export params
   */
  this.getImportParams = function() {
    return params;
  };

  this._importDumpBase64 = async function(callback) {
    const items = params.data.split(new RegExp('(RESTORE|RESTOREB64)\\s', 'g'));
    const regExpArgs = new RegExp('"?(.+?)"?\\s+"?([0-9]+)"?\\s+["\']?([a-z0-9\+/=]+?)["\']?\\s*$', 'i');
    let data;
    const promises = [];

    while ((data = items.shift()) !== undefined) {
      if (data === "") continue;
      if (data === 'RESTORE' || data === 'RESTOREB64') {
        data = items.shift();
        const callArgs = data.match(regExpArgs).slice(1, 4);
        callArgs.push(Buffer.from(callArgs.pop(), 'base64'));
        promises.push(new Promise((resolve) => {
          callArgs.push(function(err, ok) {
            if (err) {
              report.errors++;
              report.errorMsgs.push(err.message);
            }
            else {
              report.inserted++;
            }
            resolve();
          });
          this.getClient()['restore'].apply(this.getClient(), callArgs);
        }));
      }
    }
    await Promise.all(promises);
    callback();
  };

  this._importRedisType = function(callback) {
    const items = params.data.split(/(SET|LSET|RPUSH|RPUSHX|LPUSH|LPUSHX|SADD|ZADD|HSET|LTRIM)\s/g);

    /**
     * Recursive add.
     */
    const addRecursive = function() {
      if (items.length < 2) {
        callback();
        return;
      }

      /**
       * Callback function given to redis client apply() call.
       * @param {Object} err - error object if something goes wrong
       * @param {string|number} status - redis status returned from redis client function call, may be string or number
       */
      const redisCallback = function(err, status) {
        if (err) {
          callback(err);
          return;
        }

        // LPUSH / RPUSH return length of list after insert as status code, therefore cannot just add status
        // as no multi value insert allowed currently just add 1
        if (status === 'OK' || _.isNumber(status)) {
          report.inserted += 1;
        }
        else {
          // Hm...
          report.errors += 1;
        }

        addRecursive();
      };

      let callArgs;
      let command;
      do {
        command = items.shift().trim();
      }
      while (command === '');
      const args = items.shift();

      if (!(command && args)) return;

      try {
        switch (command) {
          case 'SET':
          case 'SADD':
          case 'LPUSH':
          case 'LPUSHX':
          case 'RPUSH':
          case 'RPUSHX':
            // only simple form with one value is allowed, no options (EX, NX, ...)
            callArgs = args.match(new RegExp('"?(.+?)"?\\s+(["\'](.+?)["\']|(.+?))(?:\\s|$)', 'i')).slice(1, 3);
            callArgs[1] = callArgs[1].replace(/(^["']|["']$)/g, '');   // remove optional quotes around value string
            break;

          case 'ZADD':
          case 'LSET':
            // only simple form with one value: "ZADD key 1 value", no options (NX, XX, ...)
            callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?([0-9]+?)"?\\s+(["\'](.+?)["\']|(.+?))(\\s|$)', 'i')).slice(1, 4);
            callArgs[2] = callArgs[2].replace(/(^["']|["']$)/g, '');   // remove optional quotes around value string
            break;

          case 'HSET':
            callArgs = args.match(new RegExp('"?(.+?)"?\\s+"?(.+?)"?\\s+(["\'](.+?)["\']|(.+?))\\s*$', 'i')).slice(1, 4);
            callArgs[2] = callArgs[2].replace(/(^["']|["']$)/g, '');   // remove optional quotes around value string
            break;

          case 'LTRIM':
            // command "LTRIM key 1 1"
            callArgs = args.match(new RegExp('"?(.+?)"?\\s+([0-9]+?)\\s+([0-9]+?)\\s*$', 'i')).slice(1, 4);
            break;

          default:
            console.error(command, args);
            callback('Error import data! Not supported type!');
            return;
        }
      }
      catch (errCmd) {
        callback('FAIL parse command of known type: ' + command);
      }

      callArgs.push(redisCallback);
      this.getClient()[command.toLowerCase()].apply(this.getClient(), callArgs);
    }.bind(this);

    addRecursive();
  }

  async.waterfall([
    /**
     * Check import type given
     * @param {function} callback - async waterfall callback
     */
    function(callback) {
      if (!this.getImportParams().type) {
        this.getImportParams().type = 'redis';
      }

      switch (this.getImportParams().type) {
        case 'redis':
        case 'dump-base64':
          callback();
          break;
        default:
          callback('Import type "' + this.getImportParams().type + '" is not supported!');
      }
    }.bind(this),

    /**
     * Select DB if need.
     * @param {function} callback - async waterfall callback
     */
    function(callback) {
      this.selectDb(this.getImportParams().db, callback);
    }.bind(this),

    /**
     * Flush all if need.
     * @param {function} callback - async waterfall callback
     */
    function(callback) {
      if (this.getImportParams().clear) {
        console.log('clear db');
        this.getClient().flushdb();
      }
      callback();
    }.bind(this),

    /**
     * Import data into redis
     * @param {function} callback - async waterfall callback
     */
    function(callback) {
      if (this.getImportParams().type === 'dump-base64')  this._importDumpBase64(callback)
      else this._importRedisType(callback);
    }.bind(this)
  ], function(err) {
    if (!_.isFunction(params.callback)) {
      params.callback = function() {
        // intentionally empty
      };
    }

    params.callback(err, report);
  });
};

module.exports = RedisDump;
