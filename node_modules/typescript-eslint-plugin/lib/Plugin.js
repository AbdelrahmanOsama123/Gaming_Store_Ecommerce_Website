"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plugin = void 0;
const util_1 = require("util");
const Path = require("upath");
const Constants_1 = require("./Constants");
const DiagnosticIDDecorator_1 = require("./Diagnostics/DiagnosticIDDecorator");
const LintDiagnosticMap_1 = require("./Diagnostics/LintDiagnosticMap");
const Interceptor_1 = require("./Interception/Interceptor");
const LogLevel_1 = require("./Logging/LogLevel");
const PluginLogger_1 = require("./Logging/PluginLogger");
const ESLintRunner_1 = require("./Runner/ESLintRunner");
const ConfigurationManager_1 = require("./Settings/ConfigurationManager");
/**
 * Represents a service for handling `eslint`-warnings.
 */
class Plugin {
    /**
     * Initializes a new instance of the `Plugin` class.
     *
     * @param pluginModule
     * The module of this plugin.
     *
     * @param pluginInfo
     * The information about the plugin.
     */
    constructor(pluginModule, pluginInfo) {
        var _a, _b;
        /**
         * A component for logging messages.
         */
        this.logger = new PluginLogger_1.PluginLogger(this, Constants_1.Constants.PluginName);
        /**
         * A component for managing configurations.
         */
        this.configurationManager = new ConfigurationManager_1.ConfigurationManager(this);
        /**
         * The fix-actions for the project.
         */
        this.lintDiagnostics = new Map();
        /**
         * A component for decorating fix-ids.
         */
        this.idDecorator = new DiagnosticIDDecorator_1.DiagnosticIDDecorator();
        this.ConfigurationManager.PluginInfo = pluginInfo;
        this.pluginModule = pluginModule;
        (_a = this.Logger) === null || _a === void 0 ? void 0 : _a.Info("Initializing the plugin…");
        (_b = this.Logger) === null || _b === void 0 ? void 0 : _b.Verbose(`Configuration: ${JSON.stringify(pluginInfo.config)}`);
        this.runner = new ESLintRunner_1.ESLintRunner(this);
        this.ConfigurationManager.ConfigUpdated.add(() => {
            var _a;
            (_a = this.Logger) === null || _a === void 0 ? void 0 : _a.Info("TSConfig configuration changed…");
            this.Project.refreshDiagnostics();
        });
    }
    /**
     * Gets the module of this plugin.
     */
    get PluginModule() {
        return this.pluginModule;
    }
    /**
     * Gets the typescript-service.
     */
    get TypeScript() {
        return this.PluginModule.TypeScript;
    }
    /**
     * Gets a component for writing log-messages.
     */
    get RealLogger() {
        return this.logger;
    }
    /**
     * Gets a component for writing log-messages.
     */
    get Logger() {
        if (this.Config.LogLevel !== LogLevel_1.LogLevel.None) {
            return this.RealLogger;
        }
        else {
            return null;
        }
    }
    /**
     * Gets a component for managing configurations.
     */
    get ConfigurationManager() {
        return this.configurationManager;
    }
    /**
     * Gets the configuration.
     */
    get Config() {
        return this.ConfigurationManager.Config;
    }
    /**
     * Gets or sets information for the plugin.
     */
    get PluginInfo() {
        return this.ConfigurationManager.PluginInfo;
    }
    /**
     * Gets the language-service host.
     */
    get LanguageServiceHost() {
        return this.PluginInfo.languageServiceHost;
    }
    /**
     * Gets the project of the language-server.
     */
    get Project() {
        return this.PluginInfo.project;
    }
    /**
     * Gets the program of the language-service.
     */
    get Program() {
        return this.Project.getLanguageService().getProgram();
    }
    /**
     * Updates the configuration.
     *
     * @param config
     * The configuration to set.
     */
    UpdateConfig(config) {
        var _a;
        (_a = this.Logger) === null || _a === void 0 ? void 0 : _a.Info("Updating the configuration…");
        this.ConfigurationManager.Update(config);
    }
    /**
     * Adds the plugin to the specified language-service.
     *
     * @param languageService
     * The language-service to add the plugin to.
     *
     * @returns
     * The decorated language-service.
     */
    Decorate(languageService) {
        var _a;
        if (!languageService[Constants_1.Constants.PluginInstalledSymbol] &&
            !((_a = languageService[Constants_1.Constants.PluginInstalledDescription]) === null || _a === void 0 ? void 0 : _a.call(languageService))) {
            let oldGetSupportedCodeFixes = this.TypeScript.getSupportedCodeFixes.bind(this.TypeScript);
            this.TypeScript.getSupportedCodeFixes = () => [
                ...oldGetSupportedCodeFixes(),
                Constants_1.Constants.ErrorCode.toString()
            ];
            let interceptor = new Interceptor_1.Interceptor(languageService, true);
            this.InstallInterceptions(interceptor);
            languageService[Constants_1.Constants.PluginInstalledDescription] = () => true;
            languageService[Constants_1.Constants.PluginInstalledSymbol] = true;
            interceptor.AddProperty(Constants_1.Constants.PluginInstalledSymbol, () => true);
            return interceptor.Proxy;
        }
        else {
            return languageService;
        }
    }
    /**
     * Creates diagnostic for a message.
     *
     * @param message
     * The message to create a diagnostic for.
     *
     * @param errorLevel
     * The error-level of the message.
     *
     * @param file
     * The file to add the diagnostic to.
     *
     * @returns
     * The newly created message.
     */
    CreateMessage(message, errorLevel, file) {
        return this.CreateDiagnostic(file, { start: 0, length: 1 }, message, errorLevel);
    }
    /**
     * Creates a diagnostic for a deprecated rule.
     *
     * @param file
     * The file to add the diagnostic to.
     *
     * @param deprecation
     * The depreaction to create a warning for.
     *
     * @returns
     * The newly created deprecation-warning.
     */
    CreateDeprecationWarning(file, deprecation) {
        let message = `The rule \`${deprecation.ruleId}\` is deprecated.\n`;
        message += "Please use ";
        if (deprecation.replacedBy.length > 1) {
            message += "these alternatives:\n";
            message += deprecation.replacedBy.slice(0, deprecation.replacedBy.length - 1).map((replacement) => `\`${replacement}\``).join(", ");
            message += ` and \`${deprecation.replacedBy[deprecation.replacedBy.length - 1]}\``;
        }
        else {
            message += `\`${deprecation.replacedBy[0]}\` instead.`;
        }
        return this.CreateDiagnostic(file, { start: 0, length: 1 }, message, this.TypeScript.DiagnosticCategory.Warning);
    }
    /**
     * Creates a diagnostic-object for a lint-message.
     *
     * @param lintMessage
     * The lint-message to add.
     *
     * @param file
     * The file to add the diagnostic to.
     *
     * @returns
     * The newly created lint-message.
     */
    CreateLintMessage(lintMessage, file) {
        let category;
        let message = `${lintMessage.message}`;
        if (lintMessage.ruleId) {
            message = `${message} (${lintMessage.ruleId})`;
        }
        let span = this.GetTextSpan(file, lintMessage);
        if (!this.Config.AlwaysShowRuleFailuresAsWarnings) {
            switch (lintMessage.severity) {
                case 1:
                    category = this.TypeScript.DiagnosticCategory.Warning;
                    break;
                case 2:
                    category = this.TypeScript.DiagnosticCategory.Error;
                    break;
            }
        }
        else {
            category = this.TypeScript.DiagnosticCategory.Warning;
        }
        return this.CreateDiagnostic(file, span, message, category !== null && category !== void 0 ? category : this.TypeScript.DiagnosticCategory.Warning);
    }
    /**
     * Creates a diagnostic for the specified text-span.
     *
     * @param file
     * The file to create a diagnostic for.
     *
     * @param textSpan
     * The text-span to create a diagnostic for.
     *
     * @param message
     * The message of the diagnostic.
     *
     * @param category
     * The category of the diagnostic.
     *
     * @returns
     * The newly created diagnostic.
     */
    CreateDiagnostic(file, textSpan, message, category) {
        return {
            file,
            start: textSpan.start,
            length: textSpan.length,
            messageText: message,
            category,
            source: Constants_1.Constants.ErrorSource,
            code: Constants_1.Constants.ErrorCode
        };
    }
    /**
     * Gets the text-span of a lint-message.
     *
     * @param file
     * The file to get the position.
     *
     * @param lintMessage
     * The lint-message whose text-span to get.
     *
     * @returns
     * The text-span of the lint-message.
     */
    GetTextSpan(file, lintMessage) {
        var _a, _b;
        /**
         * Resolves the position of a line- and column-number.
         *
         * @param line
         * The line to resolve.
         *
         * @param column
         * The column to resolve.
         *
         * @returns
         * A number representing the text-position.
         */
        let positionResolver = (line, column) => {
            if (line) {
                let result;
                let lineStarts = file.getLineStarts();
                if (line > lineStarts.length) {
                    result = file.getLineEndOfPosition(lineStarts[lineStarts.length - 1]);
                }
                else {
                    let lineStart = lineStarts[line - 1];
                    let lineEnd = file.getLineEndOfPosition(lineStart);
                    line--;
                    if (util_1.isNullOrUndefined(column)) {
                        result = lineEnd;
                    }
                    else {
                        column--;
                        if (column <= (file.getLineEndOfPosition(lineStart) - lineStart)) {
                            result = file.getPositionOfLineAndCharacter(line, column);
                        }
                        else {
                            result = lineEnd;
                        }
                    }
                }
                return result;
            }
            else {
                return null;
            }
        };
        let start = (_a = positionResolver(lintMessage.line, lintMessage.column)) !== null && _a !== void 0 ? _a : 0;
        let end = (_b = positionResolver(lintMessage.endLine, lintMessage.endColumn)) !== null && _b !== void 0 ? _b : start;
        return {
            start,
            length: end - start
        };
    }
    /**
     * Installs interceptions to the interceptor.
     *
     * @param interceptor
     * The interceptor to install the interceptions to.
     */
    InstallInterceptions(interceptor) {
        interceptor.AddMethod("getSemanticDiagnostics", (target, delegate, fileName) => {
            var _a, _b, _c, _d;
            let diagnostics = delegate(fileName);
            if (!this.Config.SuppressWhileTypeErrorsPresent || (diagnostics.length === 0)) {
                let result;
                let file = this.Program.getSourceFile(fileName);
                try {
                    (_a = this.Logger) === null || _a === void 0 ? void 0 : _a.Info(`Computing eslint semantic diagnostics for '${fileName}'…`);
                    if (this.lintDiagnostics.has(fileName)) {
                        this.lintDiagnostics.delete(fileName);
                    }
                    result = this.runner.RunESLint(file);
                    for (let warning of result.warnings) {
                        diagnostics.unshift(this.CreateMessage(warning, this.TypeScript.DiagnosticCategory.Warning, file));
                    }
                    if (!this.Config.SuppressDeprecationWarnings) {
                        for (let deprecation of result.report.usedDeprecatedRules) {
                            diagnostics.unshift(this.CreateDeprecationWarning(file, deprecation));
                        }
                    }
                    let lintMessages = this.FilterMessagesForFile(fileName, result.report);
                    for (let lintMessage of lintMessages) {
                        if (lintMessage.severity > 0) {
                            let diagnostic = this.CreateLintMessage(lintMessage, file);
                            diagnostics.push(diagnostic);
                            let fixable = !util_1.isNullOrUndefined(lintMessage.fix);
                            let documentDiagnostics = this.lintDiagnostics.get(file.fileName);
                            if (util_1.isNullOrUndefined(documentDiagnostics)) {
                                documentDiagnostics = new LintDiagnosticMap_1.LintDiagnosticMap();
                                this.lintDiagnostics.set(file.fileName, documentDiagnostics);
                            }
                            documentDiagnostics.Set(diagnostic.start, diagnostic.start + diagnostic.length, {
                                lintMessage,
                                fixable
                            });
                        }
                    }
                }
                catch (exception) {
                    if (!(exception instanceof Error) ||
                        exception.constructor.name !== "ConfigurationNotFoundError" ||
                        !this.Config.SuppressConfigNotFoundError) {
                        (_b = this.Logger) === null || _b === void 0 ? void 0 : _b.Info(`eslint-language service error: ${exception}`);
                        if (exception instanceof Error) {
                            (_c = this.Logger) === null || _c === void 0 ? void 0 : _c.Info(`Stack trace: ${exception.stack}`);
                        }
                        let errorMessage = "unknown error";
                        if (typeof exception.message === "string" || exception.message instanceof String) {
                            errorMessage = exception.message;
                        }
                        (_d = this.Logger) === null || _d === void 0 ? void 0 : _d.Info(`eslint error ${errorMessage}`);
                        diagnostics.unshift(this.CreateMessage(errorMessage, this.TypeScript.DiagnosticCategory.Error, file));
                        return diagnostics;
                    }
                }
            }
            return diagnostics;
        });
        interceptor.AddMethod("getCodeFixesAtPosition", (target, delegate, fileName, start, end, errorCodes, formatOptions, userPreferences) => {
            var _a, _b, _c;
            (_a = this.Logger) === null || _a === void 0 ? void 0 : _a.Verbose(`Code-fixes requested from offset ${start} to ${end}`);
            let fixes = Array.from(delegate(fileName, start, end, errorCodes, formatOptions, userPreferences));
            if ((fixes.length === 0) || !this.Config.SuppressWhileTypeErrorsPresent) {
                (_b = this.Logger) === null || _b === void 0 ? void 0 : _b.Verbose("Searching for code fixes…");
                let documentDiagnostics = this.lintDiagnostics.get(fileName);
                (_c = this.Logger) === null || _c === void 0 ? void 0 : _c.Verbose(`The current file has${documentDiagnostics ? "" : "no"} diagnostics.`);
                if (documentDiagnostics) {
                    let lintDiagnostic = documentDiagnostics.Get(start, end);
                    if (lintDiagnostic) {
                        if (lintDiagnostic.fixable) {
                            let fix = this.CreateFixAction(fileName, lintDiagnostic.lintMessage);
                            if (this.GetFixableDiagnostics(fileName, lintDiagnostic.lintMessage.ruleId).length > 1) {
                                fix.fixId = this.idDecorator.DecorateCombinedFix(lintDiagnostic.lintMessage.ruleId);
                                fix.fixAllDescription = `Fix all: ${lintDiagnostic.lintMessage.ruleId}`;
                            }
                            fixes.push(fix);
                            fixes.push(this.CreateFixAllQuickFix(fileName));
                        }
                        fixes.push(this.CreateDisableRuleFix(this.Program.getSourceFile(fileName), lintDiagnostic.lintMessage));
                    }
                }
            }
            return fixes;
        });
        interceptor.AddMethod("getCombinedCodeFix", (target, delegate, scope, fixId, formatOptions, preferences) => {
            let ruleName = this.idDecorator.UndecorateCombinedFix(String(fixId));
            if (ruleName !== undefined) {
                let fixes = this.GetFixableDiagnostics(scope.fileName, ruleName).map((diagnostic) => diagnostic.lintMessage.fix);
                if (fixes.length > 0) {
                    return {
                        changes: [
                            {
                                fileName: scope.fileName,
                                textChanges: fixes.map((fix) => this.ConvertFixToTextChange(fix))
                            }
                        ]
                    };
                }
                else {
                    return { changes: [] };
                }
            }
            else {
                return delegate(scope, fixId, formatOptions, preferences);
            }
        });
    }
    /**
     * Converts a fix to a `TextChange` object.
     *
     * @param fix
     * The fix to convert.
     *
     * @returns
     * A `ts.TextChange` object representing the rule-fix.
     */
    ConvertFixToTextChange(fix) {
        return {
            newText: fix.text,
            span: {
                start: fix.range[0],
                length: fix.range[1] - fix.range[0]
            }
        };
    }
    /**
     * Gets all lint-diagnostics with the specified rule-id in the specified file.
     *
     * @param fileName
     * The file to look for lint-diagnostics.
     *
     * @param ruleID
     * The rule-ID of the lint-diagnostics to look for.
     *
     * @returns
     * The `ILintDiagnostic`s with the specified `ruleID` for the specified file.
     */
    GetLintDiagnostics(fileName, ruleID) {
        let result = [];
        for (let lintDiagnostic of this.lintDiagnostics.get(fileName).Values) {
            if (lintDiagnostic.lintMessage.ruleId === ruleID) {
                result.push(lintDiagnostic);
            }
        }
        return result;
    }
    /**
     * Gets all lint-diagnostics with the specified rule-id in the specified file which provide fixes.
     *
     * @param fileName
     * The file to look for lint-diagnostics.
     *
     * @param ruleID
     * The rule-ID of the diagnostics to look for.
     *
     * @returns
     * All fixable diagnostics with the specified rule-id for the specified file.
     */
    GetFixableDiagnostics(fileName, ruleID) {
        let result = [];
        for (let lintDiagnostic of this.GetLintDiagnostics(fileName, ruleID)) {
            if (lintDiagnostic.fixable) {
                result.push(lintDiagnostic);
            }
        }
        return result;
    }
    /**
     * Creates a fix-action.
     *
     * @param fileName
     * The name of the file to add the action to.
     *
     * @param lintMessage
     * The lint-message to convert.
     *
     * @returns
     * The newly created fix-action.
     */
    CreateFixAction(fileName, lintMessage) {
        return {
            description: `Fix: ${lintMessage.message}`,
            fixName: this.idDecorator.DecorateFix(lintMessage.ruleId),
            changes: [
                {
                    fileName,
                    textChanges: [
                        this.ConvertFixToTextChange(lintMessage.fix)
                    ]
                }
            ]
        };
    }
    /**
     * Creates a fix for all auto-fixables in the file with the specified `fileName`.
     *
     * @param fileName
     * The name of the file to create the fix for.
     *
     * @returns
     * The newly created fix-action.
     */
    CreateFixAllQuickFix(fileName) {
        let applicableFixes = [];
        let fixes = Array.from(this.lintDiagnostics.get(fileName).Values).filter((lintDiagnostic) => lintDiagnostic.fixable).map((lintDiagnostic) => lintDiagnostic.lintMessage.fix).sort((a, b) => a.range[0] - b.range[0]);
        for (let i = 0; i < fixes.length; i++) {
            if (i === 0 || !(applicableFixes[applicableFixes.length - 1].range[1] >= fixes[i].range[0])) {
                applicableFixes.push(fixes[i]);
            }
        }
        return {
            description: "Fix all auto-fixable eslint failures",
            fixName: this.idDecorator.DecorateFix("fix-all"),
            changes: [
                {
                    fileName,
                    textChanges: applicableFixes.map((fix) => this.ConvertFixToTextChange(fix))
                }
            ]
        };
    }
    /**
     * Creates a fix for disabling the rule for the specified `failure`.
     *
     * @param file
     * THe file to create the fix for.
     *
     * @param failure
     * The failure to disable.
     *
     * @returns
     * The newly created fix for disabling the rule.
     */
    CreateDisableRuleFix(file, failure) {
        let line = failure.line - 1;
        let lineStarts = file.getLineStarts();
        let lineStart = lineStarts[line];
        let prefix = "";
        let snapshot = this.LanguageServiceHost.getScriptSnapshot(file.fileName);
        if (snapshot) {
            let lineEnd = line < lineStarts.length - 1 ? lineStarts[line + 1] : file.end;
            let lineText = snapshot.getText(lineStart, lineEnd);
            prefix = /^(?<indent>\s*).*/.exec(lineText).groups["indent"];
        }
        return {
            description: `Disable rule '${failure.ruleId}'`,
            fixName: this.idDecorator.DecorateDisableFix(failure.ruleId),
            changes: [
                {
                    fileName: file.fileName,
                    textChanges: [
                        {
                            newText: `${prefix}// eslint-disable-next-line ${failure.ruleId}\n`,
                            span: { start: lineStart, length: 0 }
                        }
                    ]
                }
            ]
        };
    }
    /**
     * Filters messages for the specified file.
     *
     * @param filePath
     * The file to get the messages for.
     *
     * @param report
     * An eslint-report.
     *
     * @returns
     * The messages for the specified file.
     */
    FilterMessagesForFile(filePath, report) {
        let normalizedPath = Path.normalize(Path.resolve(filePath));
        let normalizedFiles = new Map();
        return report.results.flatMap((lintResult) => {
            let fileName = lintResult.filePath;
            if (!normalizedFiles.has(fileName)) {
                normalizedFiles.set(fileName, Path.normalize(Path.resolve(fileName)));
            }
            if (normalizedFiles.get(fileName) === normalizedPath) {
                return lintResult.messages;
            }
            else {
                return [];
            }
        });
    }
}
exports.Plugin = Plugin;
//# sourceMappingURL=Plugin.js.map