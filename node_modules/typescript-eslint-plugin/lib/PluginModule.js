"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginModule = void 0;
const util_1 = require("util");
const Plugin_1 = require("./Plugin");
/**
 * Represents the plugin-module.
 */
class PluginModule {
    /**
     * Initializes a new instance of the `PluginModule` class.
     *
     * @param typescript
     * The typescript-server.
     */
    constructor(typescript) {
        /**
         * The projects and their plugin.
         */
        this.plugins = new Map();
        this.typescript = typescript;
    }
    /**
     * Gets the typescript-server.
     */
    get TypeScript() {
        return this.typescript;
    }
    /**
     * Creates a decorated language-service.
     *
     * @param createInfo
     * Information for the plugin.
     *
     * @returns
     * The newly created language-service.
     */
    create(createInfo) {
        var _a, _b, _c, _d, _e, _f;
        let projectName = createInfo.project.projectName;
        let plugin;
        if (createInfo.project instanceof this.typescript.server.ConfiguredProject) {
            let pluginConfig = (_a = createInfo.project.getCompilerOptions().plugins) === null || _a === void 0 ? void 0 : _a.find((configEntry) => configEntry.name === createInfo.config.name);
            if (!util_1.isNullOrUndefined(pluginConfig)) {
                /**
                 * When using a plugin globally (for instance by adding it to the `typescriptServerPlugins`-contribution in a VSCode-extension)
                 * the `createInfo.config`-object contains the global settings rather than the actual plugin-settings.
                 *
                 * If `createInfo.config` and `pluginConfig` is different, `createInfo.config` must contain global settings.
                 * Global settings are redirected to `onConfigurationChanged` and `createInfo.config` is replaced by the actual plugin-config.
                 */
                if (JSON.stringify(createInfo.config) !== JSON.stringify(pluginConfig)) {
                    this.onConfigurationChanged(createInfo.config);
                    createInfo.config = pluginConfig;
                }
            }
        }
        if (!this.plugins.has(projectName)) {
            plugin = new Plugin_1.Plugin(this, createInfo);
            this.plugins.set(projectName, plugin);
            (_b = plugin.Logger) === null || _b === void 0 ? void 0 : _b.Log(`Successfully created a new plugin for '${projectName}'`);
            if (this.config) {
                (_c = plugin.Logger) === null || _c === void 0 ? void 0 : _c.Log("Applying the global config…");
                plugin.UpdateConfig(this.config);
            }
        }
        else {
            plugin = this.plugins.get(projectName);
            (_d = plugin.Logger) === null || _d === void 0 ? void 0 : _d.Log(`A plugin for '${projectName}' already exists… Updating the plugin…`);
            plugin.ConfigurationManager.PluginInfo = createInfo;
        }
        (_e = plugin.Logger) === null || _e === void 0 ? void 0 : _e.Log("Printing the configuration…");
        (_f = plugin.Logger) === null || _f === void 0 ? void 0 : _f.Log(JSON.stringify(createInfo.config));
        return plugin.Decorate(createInfo.languageService);
    }
    /**
     * Occurrs when the configuration is about to change.
     *
     * @param config
     * The configuration to apply.
     */
    onConfigurationChanged(config) {
        this.config = config;
        for (let keyValuePair of this.plugins) {
            let plugin = keyValuePair[1];
            plugin.UpdateConfig(this.config);
        }
    }
}
exports.PluginModule = PluginModule;
//# sourceMappingURL=PluginModule.js.map