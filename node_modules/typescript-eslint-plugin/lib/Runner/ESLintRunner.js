"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ESLintRunner = void 0;
const ChildProcess = require("child_process");
const Path = require("path");
const cache_1 = require("@thi.ng/cache");
const upath_1 = require("upath");
const server = require("vscode-languageserver");
const LogLevel_1 = require("../Logging/LogLevel");
const RunnerLogger_1 = require("../Logging/RunnerLogger");
const PackageManager_1 = require("../Settings/PackageManager");
/**
 * Provides the functionality to run ESLint.
 */
let ESLintRunner = /** @class */ (() => {
    class ESLintRunner {
        /**
         * Initializes a new instance of the `ESLintRunner` class.
         *
         * @param plugin
         * The plugin of the runner.
         */
        constructor(plugin) {
            /**
             * A set of documents and functions for resolving their `CLIEngine`.
             */
            this.document2LibraryCache = new cache_1.MRUCache([], { maxsize: 100 });
            /**
             * The paths to the package-managers.
             */
            this.packageManagerPaths = new Map();
            this.plugin = plugin;
        }
        /**
         * Gets the plugin of the runner.
         */
        get Plugin() {
            return this.plugin;
        }
        /**
         * Gets the typescript-server.
         */
        get TypeScript() {
            return this.Plugin.TypeScript;
        }
        /**
         * Gets a component for writing log-messages.
         */
        get RealLogger() {
            return this.Plugin.RealLogger.CreateSubLogger(ESLintRunner.name);
        }
        /**
         * Gets a component for writing log-messages.
         */
        get Logger() {
            if (this.Config.LogLevel !== LogLevel_1.LogLevel.None) {
                return this.RealLogger;
            }
            else {
                return null;
            }
        }
        /**
         * Gets a component for writing log-messages.
         */
        get RunnerLogger() {
            if (this.Config.LogLevel !== LogLevel_1.LogLevel.None) {
                return new RunnerLogger_1.RunnerLogger(this.RealLogger);
            }
            else {
                return null;
            }
        }
        /**
         * Gets the configuration of the plugin.
         */
        get Config() {
            return this.Plugin.Config;
        }
        /**
         * Gets the program of the language-server.
         */
        get Program() {
            return this.Plugin.Program;
        }
        /**
         * Gets the language-service host.
         */
        get LanguageServiceHost() {
            return this.Plugin.LanguageServiceHost;
        }
        /**
         * Checks a file using `eslint`.
         *
         * @param file
         * The file to check.
         *
         * @returns
         * The result of the lint.
         */
        RunESLint(file) {
            var _a, _b, _c, _d;
            let warnings = [];
            (_a = this.RunnerLogger) === null || _a === void 0 ? void 0 : _a.Log("RunESLint", "Starting…");
            if (!this.document2LibraryCache.has(file.fileName)) {
                try {
                    this.document2LibraryCache.set(file.fileName, this.LoadLibrary(file.fileName));
                }
                catch (_e) { }
            }
            (_b = this.RunnerLogger) === null || _b === void 0 ? void 0 : _b.Log("RunESLint", "Loaded 'eslint' library");
            let engine = (_c = this.document2LibraryCache.get(file.fileName)) === null || _c === void 0 ? void 0 : _c();
            if (!engine) {
                return Object.assign(Object.assign({}, ESLintRunner.emptyResult), { warnings: [
                        this.GetInstallFailureMessage(file.fileName)
                    ] });
            }
            (_d = this.RunnerLogger) === null || _d === void 0 ? void 0 : _d.Log("RunESLint", `Validating '${file.fileName}'…`);
            return this.Run(file, engine, warnings);
        }
        /**
         * Checks a file using `eslint`.
         *
         * @param file
         * The file to check.
         *
         * @param engine
         * The `eslint`-engine.
         *
         * @param warnings
         * An object for storing warnings.
         *
         * @returns
         * The result of the lint.
         */
        Run(file, engine, warnings) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            let result;
            let currentDirectory = process.cwd();
            let scriptKind = this.LanguageServiceHost.getScriptKind(file.fileName);
            (_a = this.RunnerLogger) === null || _a === void 0 ? void 0 : _a.Log("Run", `Starting validation for ${file.fileName}…`);
            (_b = this.RunnerLogger) === null || _b === void 0 ? void 0 : _b.Log("Run", "Detecting the ScriptKind of the file…");
            (_c = this.RunnerLogger) === null || _c === void 0 ? void 0 : _c.Log("Run", `${file.fileName} is a ${this.TypeScript.ScriptKind[this.LanguageServiceHost.getScriptKind(file.fileName)]}-file`);
            (_d = this.RunnerLogger) === null || _d === void 0 ? void 0 : _d.Log("Run", "Printing the configuration for the file…");
            (_e = this.RunnerLogger) === null || _e === void 0 ? void 0 : _e.Log("Run", this.Config.ToJSON());
            process.chdir(this.Program.getCurrentDirectory());
            if (engine.isPathIgnored(file.fileName) ||
                (this.Config.IgnoreJavaScript && [this.TypeScript.ScriptKind.JS, this.TypeScript.ScriptKind.JSX].includes(scriptKind)) ||
                (this.Config.IgnoreTypeScript && [this.TypeScript.ScriptKind.TS, this.TypeScript.ScriptKind.TSX].includes(scriptKind))) {
                (_f = this.RunnerLogger) === null || _f === void 0 ? void 0 : _f.Log("Run", `No linting: File ${file.fileName} is excluded`);
                return ESLintRunner.emptyResult;
            }
            try {
                /**
                 * ToDo: Replace with new TypeScript-version.
                 */
                let args;
                let fileName = upath_1.normalize(file.fileName);
                if (fileName.startsWith("^") ||
                    ((fileName.includes("walkThroughSnippet:/") ||
                        fileName.includes("untitled:/")) &&
                        upath_1.basename(fileName).startsWith("^")) ||
                    (fileName.includes(":^") && !fileName.includes(upath_1.sep))) {
                    args = [];
                }
                else {
                    args = [file.fileName];
                }
                (_g = this.RunnerLogger) === null || _g === void 0 ? void 0 : _g.Log("Run", "Linting: Start linting…");
                result = engine.executeOnText(file.getFullText(), ...args);
                (_h = this.RunnerLogger) === null || _h === void 0 ? void 0 : _h.Log("Run", "Linting: Ended linting");
            }
            catch (exception) {
                (_j = this.RunnerLogger) === null || _j === void 0 ? void 0 : _j.Log("Run", "An error occurred while linting");
                (_k = this.RunnerLogger) === null || _k === void 0 ? void 0 : _k.Log("Run", exception);
                if (exception instanceof Error) {
                    warnings.push(exception.message);
                }
            }
            process.chdir(currentDirectory);
            return {
                report: result,
                warnings
            };
        }
        /**
         * Processes an error which reminds the user to install `eslint`.
         *
         * @param filePath
         * The path to the file to process an error for.
         *
         * @returns
         * The text for the error-message.
         */
        GetInstallFailureMessage(filePath) {
            let config = this.Config;
            let localCommands = {
                [PackageManager_1.PackageManager.NPM]: "npm install eslint",
                [PackageManager_1.PackageManager.PNPM]: "pnpm install eslint",
                [PackageManager_1.PackageManager.Yarn]: "yarn add eslint"
            };
            let globalCommands = {
                [PackageManager_1.PackageManager.NPM]: "npm install -g eslint",
                [PackageManager_1.PackageManager.PNPM]: "pnpm install -g eslint",
                [PackageManager_1.PackageManager.Yarn]: "yarn global add eslint"
            };
            return [
                `Failed to load the ESLint library for '${filePath}'`,
                `To use ESLint, please install eslint using '${localCommands[config.PackageManager]}' or globally using '${globalCommands[this.Config.PackageManager]}'.`,
                "Be sure to restart your editor after installing eslint."
            ].join("\n");
        }
        /**
         * Determines the path to the specified `packageManager`.
         *
         * @param packageManager
         * The package-manager to get the path.
         *
         * @returns
         * The path to the global module-directory of the specified `PackageManager`.
         */
        GetPackageManagerPath(packageManager) {
            var _a, _b;
            (_a = this.RunnerLogger) === null || _a === void 0 ? void 0 : _a.Log("GetPackageManagerPath", `Trying to resolve the package manager path for ${packageManager}`);
            if (!this.packageManagerPaths.has(packageManager)) {
                let path;
                switch (packageManager) {
                    case PackageManager_1.PackageManager.NPM:
                        path = server.Files.resolveGlobalNodePath((message) => { var _a; return (_a = this.Logger) === null || _a === void 0 ? void 0 : _a.Info(message); });
                        break;
                    case PackageManager_1.PackageManager.Yarn:
                        path = server.Files.resolveGlobalYarnPath((message) => { var _a; return (_a = this.Logger) === null || _a === void 0 ? void 0 : _a.Info(message); });
                        break;
                    case PackageManager_1.PackageManager.PNPM:
                        path = ChildProcess.execSync("pnpm root -g").toString().trim();
                        break;
                }
                this.packageManagerPaths.set(packageManager, path);
            }
            (_b = this.RunnerLogger) === null || _b === void 0 ? void 0 : _b.Log("GetPackageManagerPath", `Found the package manager path for ${packageManager}`);
            return this.packageManagerPaths.get(packageManager);
        }
        /**
         * Loads the `CLIEngine` for the file with the specified `filePath`.
         *
         * @param filePath
         * The file to check.
         *
         * @returns
         * A method for loading the `CLIEngine`.
         */
        LoadLibrary(filePath) {
            var _a, _b;
            (_a = this.RunnerLogger) === null || _a === void 0 ? void 0 : _a.Log("LoadLibrary", `Trying to load 'eslint' for '${filePath}'`);
            /**
             * Resolves the global module-directory.
             *
             * @returns
             * The path to the global module-directory.
             */
            let getGlobalPath = () => this.GetPackageManagerPath(this.Config.PackageManager);
            let directory = Path.dirname(filePath);
            let esLintPath;
            try {
                esLintPath = this.ResolveESLint(undefined, directory);
                if (esLintPath.length === 0) {
                    esLintPath = this.ResolveESLint(getGlobalPath(), directory);
                }
            }
            catch (_c) {
                esLintPath = this.ResolveESLint(getGlobalPath(), directory);
            }
            if (esLintPath.length === 0) {
                throw new Error("'eslint' not found.");
            }
            else {
                (_b = this.RunnerLogger) === null || _b === void 0 ? void 0 : _b.Log("LoadLibrary", `Resolves 'eslint' to '${esLintPath}'`);
                return () => {
                    let library;
                    let engine;
                    /**
                     * Creates a new `CLIEngine`.
                     *
                     * @returns
                     * The newly created `CLIEngine`.
                     */
                    let createEngine = () => {
                        var _a;
                        let currentDirectory = process.cwd();
                        (_a = this.RunnerLogger) === null || _a === void 0 ? void 0 : _a.Log("LoadLibrary", this.Config.ToJSON());
                        process.chdir(this.Program.getCurrentDirectory());
                        let result = new library.CLIEngine({
                            cache: true,
                            allowInlineConfig: this.Config.AllowInlineConfig,
                            reportUnusedDisableDirectives: this.Config.ReportUnusedDisableDirectives,
                            useEslintrc: this.Config.UseESLintRC,
                            configFile: this.Config.ConfigFile
                        });
                        process.chdir(currentDirectory);
                        return result;
                    };
                    try {
                        library = require(esLintPath);
                        engine = createEngine();
                    }
                    catch (_a) {
                        engine = undefined;
                    }
                    return engine;
                };
            }
        }
        /**
         * Resolves the path to the `eslint`-library.
         *
         * @param nodePath
         * The global path to resolve modules.
         *
         * @param cwd
         * The directory to resolve `eslint` from.
         *
         * @returns
         * The path to the `eslint`-module.
         */
        ResolveESLint(nodePath, cwd) {
            let env = Object.assign({}, process.env);
            let nodePathKey = "NODE_PATH";
            let app = [
                `
            try
            {
                console.log(require.resolve('eslint'));
            }
            catch
            {
                console.log("");
            }`
            ].join("");
            if (nodePathKey in env) {
                env[nodePathKey] = nodePath + Path.delimiter + env[nodePathKey];
            }
            else {
                env[nodePathKey] = nodePath;
            }
            env.ELECTRON_RUN_AS_NODE = "1";
            return ChildProcess.spawnSync(process.argv0, ["-e", app], { cwd, env }).stdout.toString().trim();
        }
    }
    /**
     * An empty result.
     */
    ESLintRunner.emptyResult = {
        report: {
            errorCount: 0,
            fixableErrorCount: 0,
            fixableWarningCount: 0,
            results: [],
            warningCount: 0,
            usedDeprecatedRules: []
        },
        warnings: []
    };
    return ESLintRunner;
})();
exports.ESLintRunner = ESLintRunner;
//# sourceMappingURL=ESLintRunner.js.map