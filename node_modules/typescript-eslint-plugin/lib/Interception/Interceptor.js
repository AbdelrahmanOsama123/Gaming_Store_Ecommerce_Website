"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Interceptor = void 0;
const cloneDeep = require("lodash.clonedeep");
const InterceptionCollection_1 = require("./InterceptionCollection");
/**
 * Provides the functionality to intercept methods of an object.
 */
class Interceptor {
    /**
     * Initializes a new instance of the `Interceptor<T>` class.
     *
     * @param target
     * The target of the interceptor.
     *
     * @param freeze
     * A value indicating whether the state of the members .
     */
    constructor(target, freeze) {
        /**
         * The interceptions.
         */
        this.interceptions = new InterceptionCollection_1.InterceptionCollection();
        if (freeze) {
            let clone = cloneDeep(target);
            this.target = clone;
            for (let property of Object.getOwnPropertyNames(target)) {
                if (property in target) {
                    Object.defineProperty(this.target, property, Object.getOwnPropertyDescriptor(target, property));
                }
            }
            Object.assign(this.target, Object.assign({}, clone));
        }
        else {
            this.target = target;
        }
        this.proxy = new Proxy(this.target, {
            get: (target, property) => {
                var _a, _b;
                if (!this.Disposed) {
                    return (_b = (_a = this.interceptions.get(property)) === null || _a === void 0 ? void 0 : _a(target, property)) !== null && _b !== void 0 ? _b : target[property];
                }
                else {
                    return this.backup[property];
                }
            }
        });
    }
    /**
     * Gets the target of the interceptor.
     */
    get Target() {
        return this.target;
    }
    /**
     * Gets the installed interceptions.
     */
    get Interceptions() {
        return new Map(this.interceptions);
    }
    /**
     * Gets the proxy for intercepting calls.
     */
    get Proxy() {
        return this.proxy;
    }
    /**
     * Gets a value indicating whether the interceptor is dispoed.
     */
    get Disposed() {
        return this.disposed;
    }
    /**
     * Adds a new property-interception.
     *
     * @param key
     * The key of the interception to add.
     *
     * @param interception
     * The interception to add.
     */
    AddProperty(key, interception) {
        if (!this.interceptions.has(key)) {
            this.interceptions.set(key, (target, key) => interception(target, key));
        }
        else {
            throw new RangeError(`An interception with the key \`${key}\` already exists!`);
        }
    }
    /**
     * Adds a new interception.
     *
     * @param key
     * The key of the interception to add.
     *
     * @param interception
     * The interception to add.
     */
    AddMethod(key, interception) {
        this.AddProperty(key, (target, key) => {
            return ((...args) => interception(target, target[key], ...args));
        });
    }
    /**
     * Deletes an interception.
     *
     * @param key
     * The key to delete.
     */
    Delete(key) {
        this.interceptions.delete(key);
    }
    /**
     * Disposes the interceptor.
     */
    Dispose() {
        this.disposed = true;
        this.interceptions.clear();
        this.target = undefined;
    }
}
exports.Interceptor = Interceptor;
//# sourceMappingURL=Interceptor.js.map