'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const PI = Math.PI;
const TAU = PI * 2;
const HALF_PI = PI / 2;
const THIRD_PI = PI / 3;
const QUARTER_PI = PI / 4;
const SIXTH_PI = PI / 6;
const INV_PI = 1 / PI;
const INV_TAU = 1 / TAU;
const INV_HALF_PI = 1 / HALF_PI;
const DEG2RAD = PI / 180;
const RAD2DEG = 180 / PI;
const PHI = (1 + Math.sqrt(5)) / 2;
const SQRT2 = Math.SQRT2;
const SQRT3 = Math.sqrt(3);
const SQRT2_2 = SQRT2 / 2;
const SQRT2_3 = SQRT3 / 2;
const THIRD = 1 / 3;
const TWO_THIRD = 2 / 3;
const SIXTH = 1 / 6;
let EPS = 1e-6;

const absDiff = (x, y) => Math.abs(x - y);
const sign = (x, eps = EPS) => (x > eps ? 1 : x < -eps ? -1 : 0);

const sincos = (theta, n = 1) => [
    Math.sin(theta) * n,
    Math.cos(theta) * n,
];
const cossin = (theta, n = 1) => [
    Math.cos(theta) * n,
    Math.sin(theta) * n,
];
const absTheta = (theta) => ((theta %= TAU), theta < 0 ? TAU + theta : theta);
const absInnerAngle = (theta) => ((theta = Math.abs(theta)), theta > PI ? TAU - theta : theta);
const angleDist = (a, b) => absInnerAngle(absTheta((b % TAU) - (a % TAU)));
const atan2Abs = (y, x) => absTheta(Math.atan2(y, x));
const quadrant = (theta) => (absTheta(theta) * INV_HALF_PI) | 0;
const deg = (theta) => theta * RAD2DEG;
const rad = (theta) => theta * DEG2RAD;
const csc = (theta) => 1 / Math.sin(theta);
const sec = (theta) => 1 / Math.cos(theta);
const cot = (theta) => 1 / Math.tan(theta);
const loc = (a, b, gamma) => Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(gamma));
const normCos = (x) => {
    const x2 = x * x;
    return 1.0 + x2 * (-4 + 2 * x2);
};
const __fastCos = (x) => {
    const x2 = x * x;
    return 0.99940307 + x2 * (-0.49558072 + 0.03679168 * x2);
};
const fastCos = (theta) => {
    theta %= TAU;
    theta < 0 && (theta = -theta);
    switch ((theta * INV_HALF_PI) | 0) {
        case 0:
            return __fastCos(theta);
        case 1:
            return -__fastCos(PI - theta);
        case 2:
            return -__fastCos(theta - PI);
        default:
            return __fastCos(TAU - theta);
    }
};
const fastSin = (theta) => fastCos(HALF_PI - theta);

const abs = Math.abs;
const max = Math.max;
const eqDelta = (a, b, eps = EPS) => abs(a - b) <= eps;
const eqDeltaScaled = (a, b, eps = EPS) => abs(a - b) <= eps * max(1, abs(a), abs(b));

const isCrossOver = (a1, a2, b1, b2) => a1 < b1 && a2 > b2;
const isCrossUnder = (a1, a2, b1, b2) => a1 > b1 && a2 < b2;
const classifyCrossing = (a1, a2, b1, b2, eps = EPS) => eqDelta(a1, b1, eps) && eqDelta(a2, b2, eps)
    ? eqDelta(a1, b2, eps)
        ? "flat"
        : "equal"
    : isCrossOver(a1, a2, b1, b2)
        ? "over"
        : isCrossUnder(a1, a2, b1, b2)
            ? "under"
            : "other";

const isMinima = (a, b, c) => a > b && b < c;
const isMaxima = (a, b, c) => a < b && b > c;
const index = (pred, values, from = 0, to = values.length) => {
    to--;
    for (let i = from + 1; i < to; i++) {
        if (pred(values[i - 1], values[i], values[i + 1])) {
            return i;
        }
    }
    return -1;
};
const minimaIndex = (values, from = 0, to = values.length) => index(isMinima, values, from, to);
const maximaIndex = (values, from = 0, to = values.length) => index(isMaxima, values, from, to);
function* indices(fn, vals, from = 0, to = vals.length) {
    while (from < to) {
        const i = fn(vals, from, to);
        if (i < 0)
            return;
        yield i;
        from = i + 1;
    }
}
const minimaIndices = (values, from = 0, to = values.length) => indices(minimaIndex, values, from, to);
const maximaIndices = (values, from = 0, to = values.length) => indices(minimaIndex, values, from, to);

const clamp = (x, min, max) => (x < min ? min : x > max ? max : x);
const clamp0 = (x) => (x > 0 ? x : 0);
const clamp01 = (x) => (x < 0 ? 0 : x > 1 ? 1 : x);
const clamp11 = (x) => (x < -1 ? -1 : x > 1 ? 1 : x);
const clamp05 = (x) => (x < 0 ? 0 : x > 0.5 ? 0.5 : x);
const wrap = (x, min, max) => {
    if (min === max)
        return min;
    if (x > max) {
        const d = max - min;
        x -= d;
        if (x > max)
            x -= d * (((x - min) / d) | 0);
    }
    else if (x < min) {
        const d = max - min;
        x += d;
        if (x < min)
            x += d * (((min - x) / d + 1) | 0);
    }
    return x;
};
const wrapOnce = (x, min, max) => x < min ? x - min + max : x > max ? x - max + min : x;
const wrap01 = (x) => (x < 0 ? x + 1 : x > 1 ? x - 1 : x);
const wrap11 = (x) => (x < -1 ? x + 2 : x > 1 ? x - 2 : x);
const min2id = (a, b) => (a <= b ? 0 : 1);
const min3id = (a, b, c) => a <= b ? (a <= c ? 0 : 2) : b <= c ? 1 : 2;
const min4id = (a, b, c, d) => a <= b
    ? a <= c
        ? a <= d
            ? 0
            : 3
        : c <= d
            ? 2
            : 3
    : b <= c
        ? b <= d
            ? 1
            : 3
        : c <= d
            ? 2
            : 3;
const max2id = (a, b) => (a >= b ? 0 : 1);
const max3id = (a, b, c) => a >= b ? (a >= c ? 0 : 2) : b >= c ? 1 : 2;
const max4id = (a, b, c, d) => a >= b
    ? a >= c
        ? a >= d
            ? 0
            : 3
        : c >= d
            ? 2
            : 3
    : b >= c
        ? b >= d
            ? 1
            : 3
        : c >= d
            ? 2
            : 3;
const minNonZero2 = (a, b) => a !== 0 ? (b !== 0 ? Math.min(a, b) : a) : b;
const minNonZero3 = (a, b, c) => minNonZero2(minNonZero2(a, b), c);
const smin = (a, b, k) => smax(a, b, -k);
const smax = (a, b, k) => {
    const ea = Math.exp(a * k);
    const eb = Math.exp(b * k);
    return (a * ea + b * eb) / (ea + eb);
};
const sclamp = (x, min, max, k) => smin(smax(x, min, k), max, k);
const absMin = (a, b) => (Math.abs(a) < Math.abs(b) ? a : b);
const absMax = (a, b) => (Math.abs(a) > Math.abs(b) ? a : b);
const foldback = (e, x) => x < -e || x > e ? Math.abs(Math.abs((x - e) % (4 * e)) - 2 * e) - e : x;
const inRange = (x, min, max) => x >= min && x <= max;
const inOpenRange = (x, min, max) => x > min && x < max;

const norm = (x, a, b) => (b !== a ? (x - a) / (b - a) : 0);
const fit = (x, a, b, c, d) => c + (d - c) * norm(x, a, b);
const fitClamped = (x, a, b, c, d) => c + (d - c) * clamp01(norm(x, a, b));
const fit01 = (x, a, b) => a + (b - a) * clamp01(x);
const fit10 = (x, a, b) => b + (a - b) * clamp01(x);
const fit11 = (x, a, b) => a + (b - a) * (0.5 + 0.5 * clamp11(x));

const M8 = 0xff;
const M16 = 0xffff;
const signExtend8 = (a) => ((a &= M8), a & 0x80 ? a | ~M8 : a);
const signExtend16 = (a) => ((a &= M16), a & 0x8000 ? a | ~M16 : a);
const addi8 = (a, b) => signExtend8((a | 0) + (b | 0));
const divi8 = (a, b) => signExtend8((a | 0) / (b | 0));
const muli8 = (a, b) => signExtend8((a | 0) * (b | 0));
const subi8 = (a, b) => signExtend8((a | 0) - (b | 0));
const andi8 = (a, b) => signExtend8((a | 0) & (b | 0));
const ori8 = (a, b) => signExtend8(a | 0 | (b | 0));
const xori8 = (a, b) => signExtend8((a | 0) ^ (b | 0));
const noti8 = (a) => signExtend8(~a);
const lshifti8 = (a, b) => signExtend8((a | 0) << (b | 0));
const rshifti8 = (a, b) => signExtend8((a | 0) >> (b | 0));
const addi16 = (a, b) => signExtend16((a | 0) + (b | 0));
const divi16 = (a, b) => signExtend16((a | 0) / (b | 0));
const muli16 = (a, b) => signExtend16((a | 0) * (b | 0));
const subi16 = (a, b) => signExtend16((a | 0) - (b | 0));
const andi16 = (a, b) => signExtend16((a | 0) & (b | 0));
const ori16 = (a, b) => signExtend16(a | 0 | (b | 0));
const xori16 = (a, b) => signExtend16((a | 0) ^ (b | 0));
const noti16 = (a) => signExtend16(~a);
const lshifti16 = (a, b) => signExtend16((a | 0) << (b | 0));
const rshifti16 = (a, b) => signExtend16((a | 0) >> (b | 0));
const addi32 = (a, b) => ((a | 0) + (b | 0)) | 0;
const divi32 = (a, b) => ((a | 0) / (b | 0)) | 0;
const muli32 = (a, b) => ((a | 0) * (b | 0)) | 0;
const subi32 = (a, b) => ((a | 0) - (b | 0)) | 0;
const andi32 = (a, b) => (a | 0) & (b | 0);
const ori32 = (a, b) => a | 0 | (b | 0);
const xori32 = (a, b) => (a | 0) ^ (b | 0);
const lshifti32 = (a, b) => (a | 0) << (b | 0);
const rshifti32 = (a, b) => (a | 0) >> (b | 0);
const noti32 = (a) => ~a;
const addu8 = (a, b) => ((a & M8) + (b & M8)) & M8;
const divu8 = (a, b) => ((a & M8) / (b & M8)) & M8;
const mulu8 = (a, b) => ((a & M8) * (b & M8)) & M8;
const subu8 = (a, b) => ((a & M8) - (b & M8)) & M8;
const andu8 = (a, b) => a & M8 & (b & M8) & M8;
const oru8 = (a, b) => ((a & M8) | (b & M8)) & M8;
const xoru8 = (a, b) => ((a & M8) ^ (b & M8)) & M8;
const notu8 = (a) => ~a & M8;
const lshiftu8 = (a, b) => ((a & M8) << (b & M8)) & M8;
const rshiftu8 = (a, b) => ((a & M8) >>> (b & M8)) & M8;
const addu16 = (a, b) => ((a & M16) + (b & M16)) & M16;
const divu16 = (a, b) => ((a & M16) / (b & M16)) & M16;
const mulu16 = (a, b) => ((a & M16) * (b & M16)) & M16;
const subu16 = (a, b) => ((a & M16) - (b & M16)) & M16;
const andu16 = (a, b) => a & M16 & (b & M16) & M16;
const oru16 = (a, b) => ((a & M16) | (b & M16)) & M16;
const xoru16 = (a, b) => ((a & M16) ^ (b & M16)) & M16;
const notu16 = (a) => ~a & M16;
const lshiftu16 = (a, b) => ((a & M16) << (b & M16)) & M16;
const rshiftu16 = (a, b) => ((a & M16) >>> (b & M16)) & M16;
const addu32 = (a, b) => ((a >>> 0) + (b >>> 0)) >>> 0;
const divu32 = (a, b) => ((a >>> 0) / (b >>> 0)) >>> 0;
const mulu32 = (a, b) => ((a >>> 0) * (b >>> 0)) >>> 0;
const subu32 = (a, b) => ((a >>> 0) - (b >>> 0)) >>> 0;
const andu32 = (a, b) => ((a >>> 0) & (b >>> 0)) >>> 0;
const oru32 = (a, b) => ((a >>> 0) | (b >>> 0)) >>> 0;
const xoru32 = (a, b) => ((a >>> 0) ^ (b >>> 0)) >>> 0;
const notu32 = (a) => ~a >>> 0;
const lshiftu32 = (a, b) => ((a >>> 0) << (b >>> 0)) >>> 0;
const rshiftu32 = (a, b) => ((a >>> 0) >>> (b >>> 0)) >>> 0;

const copysign = (x, y) => Math.sign(y) * Math.abs(x);
const exp2 = (x) => 2 ** x;
const fdim = (x, y) => Math.max(x - y, 0);
const fma = (x, y, z) => x * y + z;
const fmod = (x, y) => x % y;
const frexp = (x) => {
    if (x === 0 || !isFinite(x))
        return [x, 0];
    const abs = Math.abs(x);
    let exp = Math.max(-1023, Math.floor(Math.log2(abs)) + 1);
    let y = abs * 2 ** -exp;
    while (y < 0.5) {
        y *= 2;
        exp--;
    }
    while (y >= 1) {
        y *= 0.5;
        exp++;
    }
    return [x < 0 ? -y : y, exp];
};
const ldexp = (x, exp) => x * 2 ** exp;
const remainder = (x, y) => x - y * Math.round(x / y);

const minError = (fn, error, q, res = 16, iter = 8, start = 0, end = 1, eps = EPS) => {
    if (iter <= 0)
        return (start + end) / 2;
    const delta = (end - start) / res;
    let minT = start;
    let minE = Infinity;
    for (let i = 0; i <= res; i++) {
        const t = start + i * delta;
        const e = error(q, fn(t));
        if (e < minE) {
            if (e <= eps)
                return t;
            minE = e;
            minT = t;
        }
    }
    return minError(fn, error, q, res, iter - 1, Math.max(minT - delta, 0), Math.min(minT + delta, 1));
};

const mix = (a, b, t) => a + (b - a) * t;
const mixBilinear = (a, b, c, d, u, v) => {
    const iu = 1 - u;
    const iv = 1 - v;
    return a * iu * iv + b * u * iv + c * iu * v + d * u * v;
};
const mixQuadratic = (a, b, c, t) => {
    const s = 1 - t;
    return a * s * s + b * 2 * s * t + c * t * t;
};
const mixCubic = (a, b, c, d, t) => {
    const t2 = t * t;
    const s = 1 - t;
    const s2 = s * s;
    return a * s2 * s + b * 3 * s2 * t + c * 3 * t2 * s + d * t2 * t;
};
const mixHermite = (a, b, c, d, t) => {
    const y1 = 0.5 * (c - a);
    const y2 = 1.5 * (b - c) + 0.5 * (d - a);
    return ((y2 * t + a - b + y1 - y2) * t + y1) * t + b;
};
const mixCubicHermite = (a, ta, b, tb, t) => {
    const s = t - 1;
    const t2 = t * t;
    const s2 = s * s;
    const h00 = (1 + 2 * t) * s2;
    const h10 = t * s2;
    const h01 = t2 * (3 - 2 * t);
    const h11 = t2 * s;
    return h00 * a + h10 * ta + h01 * b + h11 * tb;
};
const mixCubicHermiteFromPoints = (a, b, c, d, t) => {
    d *= 0.5;
    const aa = -0.5 * a + 1.5 * b - 1.5 * c + d;
    const bb = a - 2.5 * b + 2 * c - d;
    const cc = -0.5 * a + 0.5 * c;
    const dd = b;
    const t2 = t * t;
    return t * t2 * aa + t2 * bb + t * cc + dd;
};
const mixBicubic = (s00, s01, s02, s03, s10, s11, s12, s13, s20, s21, s22, s23, s30, s31, s32, s33, u, v) => mixCubicHermiteFromPoints(mixCubicHermiteFromPoints(s00, s01, s02, s03, u), mixCubicHermiteFromPoints(s10, s11, s12, s13, u), mixCubicHermiteFromPoints(s20, s21, s22, s23, u), mixCubicHermiteFromPoints(s30, s31, s32, s33, u), v);
const tangentCardinal = (prev, next, scale = 0.5, ta = 0, tc = 2) => scale * ((next - prev) / (tc - ta));
const tangentDiff3 = (prev, curr, next, ta = 0, tb = 1, tc = 2) => 0.5 * ((next - curr) / (tc - tb) + (curr - prev) / (tb - ta));
const tween = (f, from, to) => (t) => mix(from, to, f(t));
const circular = (t) => {
    t = 1 - t;
    return Math.sqrt(1 - t * t);
};
const invCircular = (t) => 1 - circular(1 - t);
const lens = (pos, strength, t) => {
    const impl = strength > 0 ? invCircular : circular;
    const tp = 1 - pos;
    const tl = t <= pos ? impl(t / pos) * pos : 1 - impl((1 - t) / tp) * tp;
    return mix(t, tl, Math.abs(strength));
};
const cosine = (t) => 1 - (Math.cos(t * PI) * 0.5 + 0.5);
const decimated = (n, t) => Math.floor(t * n) / n;
const bounce = (k, amp, t) => {
    const tk = t * k;
    return 1 - ((amp * Math.sin(tk)) / tk) * Math.cos(t * HALF_PI);
};
const ease = (ease, t) => Math.pow(t, ease);
const impulse = (k, t) => {
    const h = k * t;
    return h * Math.exp(1 - h);
};
const gain = (k, t) => t < 0.5 ? 0.5 * Math.pow(2 * t, k) : 1 - 0.5 * Math.pow(2 - 2 * t, k);
const parabola = (k, t) => Math.pow(4.0 * t * (1.0 - t), k);
const cubicPulse = (w, c, t) => {
    t = Math.abs(t - c);
    return t > w ? 0 : ((t /= w), 1 - t * t * (3 - 2 * t));
};
const sinc = (t) => (t !== 0 ? Math.sin(t) / t : 1);
const sincNormalized = (k, t) => sinc(PI * k * t);
const lanczos = (a, t) => t !== 0 ? (-a < t && t < a ? sinc(PI * t) * sinc((PI * t) / a) : 0) : 1;
const sigmoid = (bias, k, t) => t != bias ? 1 / (1 + Math.exp(-k * (t - bias))) : 0.5;
const sigmoid01 = (k, t) => sigmoid(0.5, k, t);
const sigmoid11 = (k, t) => sigmoid(0, k, t);
const schlick = (a, b, t) => t <= b
    ? (b * t) / (t + a * (b - t) + EPS)
    : ((1 - b) * (t - 1)) / (1 - t - a * (b - t) + EPS) + 1;
const expFactor = (a, b, num) => (b / a) ** (1 / num);
const gaussian = (bias, sigma, t) => Math.exp(-((t - bias) ** 2) / (2 * sigma * sigma));

const mod = (a, b) => a - b * Math.floor(a / b);
const fract = (x) => x - Math.floor(x);
const trunc = (x) => (x < 0 ? Math.ceil(x) : Math.floor(x));
const roundTo = (x, prec = 1) => Math.round(x / prec) * prec;
const floorTo = (x, prec = 1) => Math.floor(x / prec) * prec;
const ceilTo = (x, prec = 1) => Math.ceil(x / prec) * prec;
const roundEps = (x, eps = EPS) => {
    const f = fract(x);
    return f <= eps || f >= 1 - eps ? Math.round(x) : x;
};

const simplifyRatio = (num, denom) => {
    let e1 = Math.abs(num);
    let e2 = Math.abs(denom);
    while (true) {
        if (e1 < e2) {
            const t = e1;
            e1 = e2;
            e2 = t;
        }
        const r = e1 % e2;
        if (r) {
            e1 = r;
        }
        else {
            return [num / e2, denom / e2];
        }
    }
};

const safeDiv = (a, b) => (b !== 0 ? a / b : 0);

const derivative = (f, eps = EPS) => (x) => (f(x + eps) - f(x)) / eps;
const solveLinear = (a, b) => safeDiv(-b, a);
const solveQuadratic = (a, b, c, eps = 1e-9) => {
    const d = 2 * a;
    let r = b * b - 4 * a * c;
    return r < 0
        ? []
        : r < eps
            ? [-b / d]
            : ((r = Math.sqrt(r)), [(-b - r) / d, (-b + r) / d]);
};
const solveCubic = (a, b, c, d, eps = 1e-9) => {
    const aa = a * a;
    const bb = b * b;
    const ba3 = b / (3 * a);
    const p = (3 * a * c - bb) / (3 * aa);
    const q = (2 * bb * b - 9 * a * b * c + 27 * aa * d) / (27 * aa * a);
    if (Math.abs(p) < eps) {
        return [Math.cbrt(-q) - ba3];
    }
    else if (Math.abs(q) < eps) {
        return p < 0
            ? [-Math.sqrt(-p) - ba3, -ba3, Math.sqrt(-p) - ba3]
            : [-ba3];
    }
    else {
        const denom = (q * q) / 4 + (p * p * p) / 27;
        if (Math.abs(denom) < eps) {
            return [(-1.5 * q) / p - ba3, (3 * q) / p - ba3];
        }
        else if (denom > 0) {
            const u = Math.cbrt(-q / 2 - Math.sqrt(denom));
            return [u - p / (3 * u) - ba3];
        }
        else {
            const u = 2 * Math.sqrt(-p / 3), t = Math.acos((3 * q) / p / u) / 3, k = (2 * Math.PI) / 3;
            return [
                u * Math.cos(t) - ba3,
                u * Math.cos(t - k) - ba3,
                u * Math.cos(t - 2 * k) - ba3,
            ];
        }
    }
};

const step = (edge, x) => (x < edge ? 0 : 1);
const smoothStep = (edge, edge2, x) => {
    x = clamp01((x - edge) / (edge2 - edge));
    return (3 - 2 * x) * x * x;
};
const smootherStep = (edge, edge2, x) => {
    x = clamp01((x - edge) / (edge2 - edge));
    return x * x * x * (x * (x * 6 - 15) + 10);
};
const expStep = (k, n, x) => 1 - Math.exp(-k * Math.pow(x, n));

exports.DEG2RAD = DEG2RAD;
exports.EPS = EPS;
exports.HALF_PI = HALF_PI;
exports.INV_HALF_PI = INV_HALF_PI;
exports.INV_PI = INV_PI;
exports.INV_TAU = INV_TAU;
exports.PHI = PHI;
exports.PI = PI;
exports.QUARTER_PI = QUARTER_PI;
exports.RAD2DEG = RAD2DEG;
exports.SIXTH = SIXTH;
exports.SIXTH_PI = SIXTH_PI;
exports.SQRT2 = SQRT2;
exports.SQRT2_2 = SQRT2_2;
exports.SQRT2_3 = SQRT2_3;
exports.SQRT3 = SQRT3;
exports.TAU = TAU;
exports.THIRD = THIRD;
exports.THIRD_PI = THIRD_PI;
exports.TWO_THIRD = TWO_THIRD;
exports.absDiff = absDiff;
exports.absInnerAngle = absInnerAngle;
exports.absMax = absMax;
exports.absMin = absMin;
exports.absTheta = absTheta;
exports.addi16 = addi16;
exports.addi32 = addi32;
exports.addi8 = addi8;
exports.addu16 = addu16;
exports.addu32 = addu32;
exports.addu8 = addu8;
exports.andi16 = andi16;
exports.andi32 = andi32;
exports.andi8 = andi8;
exports.andu16 = andu16;
exports.andu32 = andu32;
exports.andu8 = andu8;
exports.angleDist = angleDist;
exports.atan2Abs = atan2Abs;
exports.bounce = bounce;
exports.ceilTo = ceilTo;
exports.circular = circular;
exports.clamp = clamp;
exports.clamp0 = clamp0;
exports.clamp01 = clamp01;
exports.clamp05 = clamp05;
exports.clamp11 = clamp11;
exports.classifyCrossing = classifyCrossing;
exports.copysign = copysign;
exports.cosine = cosine;
exports.cossin = cossin;
exports.cot = cot;
exports.csc = csc;
exports.cubicPulse = cubicPulse;
exports.decimated = decimated;
exports.deg = deg;
exports.derivative = derivative;
exports.divi16 = divi16;
exports.divi32 = divi32;
exports.divi8 = divi8;
exports.divu16 = divu16;
exports.divu32 = divu32;
exports.divu8 = divu8;
exports.ease = ease;
exports.eqDelta = eqDelta;
exports.eqDeltaScaled = eqDeltaScaled;
exports.exp2 = exp2;
exports.expFactor = expFactor;
exports.expStep = expStep;
exports.fastCos = fastCos;
exports.fastSin = fastSin;
exports.fdim = fdim;
exports.fit = fit;
exports.fit01 = fit01;
exports.fit10 = fit10;
exports.fit11 = fit11;
exports.fitClamped = fitClamped;
exports.floorTo = floorTo;
exports.fma = fma;
exports.fmod = fmod;
exports.foldback = foldback;
exports.fract = fract;
exports.frexp = frexp;
exports.gain = gain;
exports.gaussian = gaussian;
exports.impulse = impulse;
exports.inOpenRange = inOpenRange;
exports.inRange = inRange;
exports.invCircular = invCircular;
exports.isCrossOver = isCrossOver;
exports.isCrossUnder = isCrossUnder;
exports.isMaxima = isMaxima;
exports.isMinima = isMinima;
exports.lanczos = lanczos;
exports.ldexp = ldexp;
exports.lens = lens;
exports.loc = loc;
exports.lshifti16 = lshifti16;
exports.lshifti32 = lshifti32;
exports.lshifti8 = lshifti8;
exports.lshiftu16 = lshiftu16;
exports.lshiftu32 = lshiftu32;
exports.lshiftu8 = lshiftu8;
exports.max2id = max2id;
exports.max3id = max3id;
exports.max4id = max4id;
exports.maximaIndex = maximaIndex;
exports.maximaIndices = maximaIndices;
exports.min2id = min2id;
exports.min3id = min3id;
exports.min4id = min4id;
exports.minError = minError;
exports.minNonZero2 = minNonZero2;
exports.minNonZero3 = minNonZero3;
exports.minimaIndex = minimaIndex;
exports.minimaIndices = minimaIndices;
exports.mix = mix;
exports.mixBicubic = mixBicubic;
exports.mixBilinear = mixBilinear;
exports.mixCubic = mixCubic;
exports.mixCubicHermite = mixCubicHermite;
exports.mixCubicHermiteFromPoints = mixCubicHermiteFromPoints;
exports.mixHermite = mixHermite;
exports.mixQuadratic = mixQuadratic;
exports.mod = mod;
exports.muli16 = muli16;
exports.muli32 = muli32;
exports.muli8 = muli8;
exports.mulu16 = mulu16;
exports.mulu32 = mulu32;
exports.mulu8 = mulu8;
exports.norm = norm;
exports.normCos = normCos;
exports.noti16 = noti16;
exports.noti32 = noti32;
exports.noti8 = noti8;
exports.notu16 = notu16;
exports.notu32 = notu32;
exports.notu8 = notu8;
exports.ori16 = ori16;
exports.ori32 = ori32;
exports.ori8 = ori8;
exports.oru16 = oru16;
exports.oru32 = oru32;
exports.oru8 = oru8;
exports.parabola = parabola;
exports.quadrant = quadrant;
exports.rad = rad;
exports.remainder = remainder;
exports.roundEps = roundEps;
exports.roundTo = roundTo;
exports.rshifti16 = rshifti16;
exports.rshifti32 = rshifti32;
exports.rshifti8 = rshifti8;
exports.rshiftu16 = rshiftu16;
exports.rshiftu32 = rshiftu32;
exports.rshiftu8 = rshiftu8;
exports.safeDiv = safeDiv;
exports.schlick = schlick;
exports.sclamp = sclamp;
exports.sec = sec;
exports.sigmoid = sigmoid;
exports.sigmoid01 = sigmoid01;
exports.sigmoid11 = sigmoid11;
exports.sign = sign;
exports.signExtend16 = signExtend16;
exports.signExtend8 = signExtend8;
exports.simplifyRatio = simplifyRatio;
exports.sinc = sinc;
exports.sincNormalized = sincNormalized;
exports.sincos = sincos;
exports.smax = smax;
exports.smin = smin;
exports.smoothStep = smoothStep;
exports.smootherStep = smootherStep;
exports.solveCubic = solveCubic;
exports.solveLinear = solveLinear;
exports.solveQuadratic = solveQuadratic;
exports.step = step;
exports.subi16 = subi16;
exports.subi32 = subi32;
exports.subi8 = subi8;
exports.subu16 = subu16;
exports.subu32 = subu32;
exports.subu8 = subu8;
exports.tangentCardinal = tangentCardinal;
exports.tangentDiff3 = tangentDiff3;
exports.trunc = trunc;
exports.tween = tween;
exports.wrap = wrap;
exports.wrap01 = wrap01;
exports.wrap11 = wrap11;
exports.wrapOnce = wrapOnce;
exports.xori16 = xori16;
exports.xori32 = xori32;
exports.xori8 = xori8;
exports.xoru16 = xoru16;
exports.xoru32 = xoru32;
exports.xoru8 = xoru8;
