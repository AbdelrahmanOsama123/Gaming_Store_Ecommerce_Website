'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dcons = require('@thi.ng/dcons');
var transducers = require('@thi.ng/transducers');

class LRUCache {
    constructor(pairs, opts) {
        const _opts = Object.assign({
            maxlen: Infinity,
            maxsize: Infinity,
            map: () => new Map(),
            ksize: () => 0,
            vsize: () => 0,
        }, opts);
        this.map = _opts.map();
        this.items = new dcons.DCons();
        this._size = 0;
        this.opts = _opts;
        if (pairs) {
            this.into(pairs);
        }
    }
    get length() {
        return this.items.length;
    }
    get size() {
        return this._size;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    entries() {
        return transducers.map((e) => [e.k, e], this.items);
    }
    keys() {
        return transducers.map((e) => e.k, this.items);
    }
    values() {
        return transducers.map((e) => e.v, this.items);
    }
    copy() {
        const c = this.empty();
        c.items = this.items.copy();
        let cell = c.items.head;
        while (cell) {
            c.map.set(cell.value.k, cell);
            cell = cell.next;
        }
        return c;
    }
    empty() {
        return new LRUCache(null, this.opts);
    }
    release() {
        this._size = 0;
        this.map.clear();
        const release = this.opts.release;
        if (release) {
            let e;
            while ((e = this.items.drop())) {
                release(e.k, e.v);
            }
            return true;
        }
        return this.items.release();
    }
    has(key) {
        return this.map.has(key);
    }
    get(key, notFound) {
        const e = this.map.get(key);
        if (e) {
            return this.resetEntry(e);
        }
        return notFound;
    }
    set(key, value) {
        const size = this.opts.ksize(key) + this.opts.vsize(value);
        const e = this.map.get(key);
        this._size += Math.max(0, size - (e ? e.value.s : 0));
        this.ensureSize() && this.doSetEntry(e, key, value, size);
        return value;
    }
    into(pairs) {
        for (let p of pairs) {
            this.set(p[0], p[1]);
        }
        return this;
    }
    getSet(key, retrieve) {
        const e = this.map.get(key);
        if (e) {
            return Promise.resolve(this.resetEntry(e));
        }
        return retrieve().then((v) => this.set(key, v));
    }
    delete(key) {
        const e = this.map.get(key);
        if (e) {
            this.removeEntry(e);
            return true;
        }
        return false;
    }
    resetEntry(e) {
        this.items.asTail(e);
        return e.value.v;
    }
    ensureSize() {
        const release = this.opts.release;
        const maxs = this.opts.maxsize;
        const maxl = this.opts.maxlen;
        while (this._size > maxs || this.length >= maxl) {
            const e = this.items.drop();
            if (!e) {
                return false;
            }
            this.map.delete(e.k);
            release && release(e.k, e.v);
            this._size -= e.s;
        }
        return true;
    }
    removeEntry(e) {
        const ee = e.value;
        this.map.delete(ee.k);
        this.items.remove(e);
        this.opts.release && this.opts.release(ee.k, ee.v);
        this._size -= ee.s;
    }
    doSetEntry(e, k, v, s) {
        if (e) {
            e.value.v = v;
            e.value.s = s;
            this.items.asTail(e);
        }
        else {
            this.items.push({ k, v, s });
            this.map.set(k, this.items.tail);
        }
    }
}

class MRUCache extends LRUCache {
    constructor(pairs, opts) {
        super(pairs, opts);
    }
    empty() {
        return new MRUCache(null, this.opts);
    }
    resetEntry(e) {
        this.items.asHead(e);
        return e.value.v;
    }
    doSetEntry(e, k, v, s) {
        if (e) {
            e.value.v = v;
            e.value.s = s;
            this.items.asHead(e);
        }
        else {
            this.items.cons({ k, v, s });
            this.map.set(k, this.items.head);
        }
    }
}

class TLRUCache extends LRUCache {
    constructor(pairs, opts) {
        opts = Object.assign({ ttl: 60 * 60 * 1000 }, opts);
        super(pairs, opts);
    }
    empty() {
        return new TLRUCache(null, this.opts);
    }
    has(key) {
        return this.get(key) !== undefined;
    }
    get(key, notFound) {
        const e = this.map.get(key);
        if (e) {
            if (e.value.t >= Date.now()) {
                return this.resetEntry(e);
            }
            this.removeEntry(e);
        }
        return notFound;
    }
    set(key, value, ttl = this.opts.ttl) {
        const size = this.opts.ksize(key) + this.opts.vsize(value);
        const e = this.map.get(key);
        this._size += Math.max(0, size - (e ? e.value.s : 0));
        if (this.ensureSize()) {
            const t = Date.now() + ttl;
            if (e) {
                e.value.v = value;
                e.value.s = size;
                e.value.t = t;
                this.items.asTail(e);
            }
            else {
                this.items.push({
                    k: key,
                    v: value,
                    s: size,
                    t,
                });
                this.map.set(key, this.items.tail);
            }
        }
        return value;
    }
    getSet(key, retrieve, ttl = this.opts.ttl) {
        const e = this.get(key);
        if (e) {
            return Promise.resolve(e);
        }
        return retrieve().then((v) => this.set(key, v, ttl));
    }
    prune() {
        const now = Date.now();
        let cell = this.items.head;
        while (cell) {
            if (cell.value.t < now) {
                this.removeEntry(cell);
            }
            cell = cell.next;
        }
    }
    ensureSize() {
        const maxs = this.opts.maxsize;
        const maxl = this.opts.maxlen;
        const now = Date.now();
        let cell = this.items.head;
        while (cell && (this._size > maxs || this.length >= maxl)) {
            if (cell.value.t < now) {
                this.removeEntry(cell);
            }
            cell = cell.next;
        }
        return super.ensureSize();
    }
}

exports.LRUCache = LRUCache;
exports.MRUCache = MRUCache;
exports.TLRUCache = TLRUCache;
