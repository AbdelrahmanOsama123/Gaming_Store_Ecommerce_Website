import type { Fn0 } from "@thi.ng/api";
import type { ConsCell, DCons } from "@thi.ng/dcons";
import type { CacheEntry, CacheOpts } from "./api";
import { LRUCache } from "./lru";
export interface TLRUCacheOpts<K, V> extends CacheOpts<K, V> {
    ttl: number;
}
export interface TLRUCacheEntry<K, V> extends CacheEntry<K, V> {
    t: number;
}
/**
 * Time-aware LRU cache. Extends LRU strategy with TTL (time-to-live)
 * values associated to each entry.
 *
 * @remarks
 * {@link ICache.has} will only return true and {@link ICache.get} only
 * returns a cached value if its TTL hasn't yet expired. When adding a
 * new value to the cache, first removes expired entries and if still
 * not sufficient space then removes entries in LRU order.
 *
 * {@link ICache.set} takes an optional entry specific `ttl` arg. If not
 * given, uses the cache instance's default (provided via ctor option
 * arg). If no instance TTL is given, TTL defaults to 1 hour.
 */
export declare class TLRUCache<K, V> extends LRUCache<K, V> {
    protected opts: TLRUCacheOpts<K, V>;
    protected map: Map<K, ConsCell<TLRUCacheEntry<K, V>>>;
    protected items: DCons<TLRUCacheEntry<K, V>>;
    constructor(pairs?: Iterable<[K, V]> | null, opts?: Partial<TLRUCacheOpts<K, V>>);
    empty(): TLRUCache<K, V>;
    has(key: K): boolean;
    get(key: K, notFound?: any): any;
    set(key: K, value: V, ttl?: number): V;
    getSet(key: K, retrieve: Fn0<Promise<V>>, ttl?: number): Promise<V>;
    prune(): void;
    protected ensureSize(): boolean;
}
//# sourceMappingURL=tlru.d.ts.map