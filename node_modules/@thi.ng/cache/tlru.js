import { LRUCache } from "./lru";
/**
 * Time-aware LRU cache. Extends LRU strategy with TTL (time-to-live)
 * values associated to each entry.
 *
 * @remarks
 * {@link ICache.has} will only return true and {@link ICache.get} only
 * returns a cached value if its TTL hasn't yet expired. When adding a
 * new value to the cache, first removes expired entries and if still
 * not sufficient space then removes entries in LRU order.
 *
 * {@link ICache.set} takes an optional entry specific `ttl` arg. If not
 * given, uses the cache instance's default (provided via ctor option
 * arg). If no instance TTL is given, TTL defaults to 1 hour.
 */
export class TLRUCache extends LRUCache {
    constructor(pairs, opts) {
        opts = Object.assign({ ttl: 60 * 60 * 1000 }, opts);
        super(pairs, opts);
    }
    empty() {
        return new TLRUCache(null, this.opts);
    }
    has(key) {
        return this.get(key) !== undefined;
    }
    get(key, notFound) {
        const e = this.map.get(key);
        if (e) {
            if (e.value.t >= Date.now()) {
                return this.resetEntry(e);
            }
            this.removeEntry(e);
        }
        return notFound;
    }
    set(key, value, ttl = this.opts.ttl) {
        const size = this.opts.ksize(key) + this.opts.vsize(value);
        const e = this.map.get(key);
        this._size += Math.max(0, size - (e ? e.value.s : 0));
        if (this.ensureSize()) {
            const t = Date.now() + ttl;
            if (e) {
                e.value.v = value;
                e.value.s = size;
                e.value.t = t;
                this.items.asTail(e);
            }
            else {
                this.items.push({
                    k: key,
                    v: value,
                    s: size,
                    t,
                });
                this.map.set(key, this.items.tail);
            }
        }
        return value;
    }
    getSet(key, retrieve, ttl = this.opts.ttl) {
        const e = this.get(key);
        if (e) {
            return Promise.resolve(e);
        }
        return retrieve().then((v) => this.set(key, v, ttl));
    }
    prune() {
        const now = Date.now();
        let cell = this.items.head;
        while (cell) {
            if (cell.value.t < now) {
                this.removeEntry(cell);
            }
            cell = cell.next;
        }
    }
    ensureSize() {
        const maxs = this.opts.maxsize;
        const maxl = this.opts.maxlen;
        const now = Date.now();
        let cell = this.items.head;
        while (cell && (this._size > maxs || this.length >= maxl)) {
            if (cell.value.t < now) {
                this.removeEntry(cell);
            }
            cell = cell.next;
        }
        return super.ensureSize();
    }
}
