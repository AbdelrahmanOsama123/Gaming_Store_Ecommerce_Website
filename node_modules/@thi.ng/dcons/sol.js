import { outOfBounds } from "@thi.ng/errors";
import { DCons } from "./dcons";
/**
 * Self-organizing version of {@link DCons} using given re-ordering function.
 *
 * @remarks
 * The list will only be re-ordered upon execution of:
 *
 * - `nth()`
 * - `setNth()`
 * - `setTail()`
 * - `find()`
 * - `findWith()`
 *
 * Reference:
 * - https://en.wikipedia.org/wiki/Self-organizing_list
 */
export class SOL extends DCons {
    constructor(_reorder, src) {
        super(src);
        this._reorder = _reorder;
    }
    copy() {
        return new SOL(this._reorder, this);
    }
    empty() {
        return new SOL(this._reorder);
    }
    nth(n, notFound) {
        const cell = super.nthCell(n);
        return cell ? this._reorder(this, cell).value : notFound;
    }
    setNth(n, v) {
        const cell = this.nthCell(n);
        !cell && outOfBounds(n);
        this._reorder(this, cell).value = v;
        return this;
    }
    setTail(value) {
        if (this.tail) {
            this.tail.value = value;
            this._reorder(this, this.tail);
            return this;
        }
        return this.cons(value);
    }
    find(value) {
        let cell = this.head;
        while (cell) {
            if (cell.value === value) {
                return this._reorder(this, cell);
            }
            cell = cell.next;
        }
    }
    findWith(fn) {
        let cell = this.head;
        while (cell) {
            if (fn(cell.value)) {
                return this._reorder(this, cell);
            }
            cell = cell.next;
        }
    }
}
/**
 * Creates self-organizing list using Move-To-Front strategy.
 *
 * @remarks
 * Reference:
 * - https://en.wikipedia.org/wiki/Self-organizing_list#Move_to_front_method_(MTF)
 */
export const defMTF = (src) => new SOL((list, cell) => (list.asHead(cell), cell), src);
/**
 * Created self-organizing list using Swap-With-Neighbor (transpose) strategy.
 *
 * @remarks
 * Reference:
 * - https://en.wikipedia.org/wiki/Self-organizing_list#Transpose_method
 */
export const defTranspose = (src) => new SOL((list, cell) => cell.prev ? (list.swap(cell.prev, cell), cell.prev) : cell, src);
