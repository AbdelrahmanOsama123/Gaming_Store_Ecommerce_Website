import type { Comparator, Fn, IClear, ICompare, ICopy, IEmpty, IEquiv, ILength, IRelease, ISeq, ISeqable, IStack, Predicate } from "@thi.ng/api";
import { IRandom } from "@thi.ng/random";
import { IReducible, ReductionFn } from "@thi.ng/transducers";
export interface ConsCell<T> {
    value: T;
    next: ConsCell<T> | undefined;
    prev: ConsCell<T> | undefined;
}
export declare class DCons<T> implements IClear, ICompare<DCons<T>>, ICopy<DCons<T>>, IEmpty<DCons<T>>, IEquiv, ILength, IReducible<any, T>, IRelease, ISeqable<T>, IStack<T, T, DCons<T>> {
    head: ConsCell<T> | undefined;
    tail: ConsCell<T> | undefined;
    protected _length: number;
    constructor(src?: Iterable<T>);
    get length(): number;
    copy(): DCons<T>;
    empty(): DCons<T>;
    clear(): void;
    release(): boolean;
    compare(o: DCons<T>): number;
    equiv(o: any): boolean;
    [Symbol.iterator](): Generator<T, void, unknown>;
    /** {@inheritDoc @thi.ng/api#ISeqable.seq} */
    seq(start?: number, end?: number): ISeq<T> | undefined;
    cycle(): Generator<T, void, unknown>;
    /** {@inheritDoc @thi.ng/transducers#IReducible.$reduce} */
    $reduce(rfn: ReductionFn<any, T>, acc: any): any;
    drop(): T | undefined;
    cons(value: T): DCons<T>;
    insertBefore(cell: ConsCell<T>, value: T): DCons<T>;
    insertAfter(cell: ConsCell<T>, value: T): DCons<T>;
    insertBeforeNth(n: number, x: T): DCons<T>;
    insertAfterNth(n: number, x: T): DCons<T>;
    insertSorted(value: T, cmp?: Comparator<T>): DCons<T>;
    find(value: T): ConsCell<T> | undefined;
    findWith(fn: Predicate<T>): ConsCell<T> | undefined;
    concat(...slices: Iterable<T>[]): DCons<T>;
    into(src: Iterable<T>): void;
    slice(from?: number, to?: number): DCons<T>;
    splice(at: ConsCell<T> | number, del?: number, insert?: Iterable<T>): DCons<T>;
    remove(cell: ConsCell<T>): this;
    swap(a: ConsCell<T>, b: ConsCell<T>): DCons<T>;
    push(value: T): DCons<T>;
    pop(): T | undefined;
    first(): T | undefined;
    peek(): T | undefined;
    setHead(v: T): DCons<T>;
    setTail(v: T): DCons<T>;
    setNth(n: number, v: T): this;
    nth(n: number, notFound?: T): T | undefined;
    nthCell(n: number): ConsCell<T> | undefined;
    rotateLeft(): DCons<T>;
    rotateRight(): DCons<T>;
    map<R>(fn: Fn<T, R>): DCons<R>;
    filter(pred: Predicate<T>): DCons<T>;
    reduce<R>(rfn: ReductionFn<R, T>, initial: R): R;
    /**
     * Shuffles list by probabilistically moving cells to head or tail
     * positions.
     *
     * @remarks
     * Supports configurable iterations and custom PRNG via
     * {@link @thi.ng/random#IRandom} (default:
     * {@link @thi.ng/random#SYSTEM}).
     *
     * Default iterations: `ceil(3/2 * log2(n))`
     *
     * @param iter -
     * @param rnd -
     */
    shuffle(iter?: number, rnd?: IRandom): this;
    /**
     * Merge sort implementation based on Simon Tatham's algorithm:
     * https://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
     *
     * @remarks
     * Uses {@link @thi.ng/compare#compare} as default comparator.
     *
     * @param cmp -
     */
    sort(cmp?: Comparator<T>): this;
    reverse(): this;
    asHead(cell: ConsCell<T>): this;
    asTail(cell: ConsCell<T>): this;
    toString(): any;
    toJSON(): T[];
    protected nthCellUnsafe(n: number): ConsCell<T>;
}
/**
 * Functional syntax sugar for `new DCons(src?)`.
 *
 * @param src -
 */
export declare const defDCons: <T>(src?: Iterable<T> | undefined) => DCons<T>;
/**
 * @deprecated use {@link defDCons} instead
 */
export declare const dcons: <T>(src?: Iterable<T> | undefined) => DCons<T>;
//# sourceMappingURL=dcons.d.ts.map