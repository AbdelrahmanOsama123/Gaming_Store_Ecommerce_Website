'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errors = require('@thi.ng/errors');

function comp(...fns) {
    let [a, b, c, d, e, f, g, h, i, j] = fns;
    switch (fns.length) {
        case 0:
            errors.illegalArity(0);
        case 1:
            return a;
        case 2:
            return (...xs) => a(b(...xs));
        case 3:
            return (...xs) => a(b(c(...xs)));
        case 4:
            return (...xs) => a(b(c(d(...xs))));
        case 5:
            return (...xs) => a(b(c(d(e(...xs)))));
        case 6:
            return (...xs) => a(b(c(d(e(f(...xs))))));
        case 7:
            return (...xs) => a(b(c(d(e(f(g(...xs)))))));
        case 8:
            return (...xs) => a(b(c(d(e(f(g(h(...xs))))))));
        case 9:
            return (...xs) => a(b(c(d(e(f(g(h(i(...xs)))))))));
        case 10:
        default:
            const fn = (...xs) => a(b(c(d(e(f(g(h(i(j(...xs))))))))));
            return fns.length === 10 ? fn : comp(fn, ...fns.slice(10));
    }
}
function compL(...fns) {
    return comp.apply(null, fns.reverse());
}
const compI = compL;

function complement(f) {
    return (...xs) => !f(...xs);
}

const constantly = (x) => () => x;

const delay = (body) => new Delay(body);
class Delay {
    constructor(body) {
        this.body = body;
        this.realized = false;
    }
    deref() {
        if (!this.realized) {
            this.value = this.body();
            this.realized = true;
        }
        return this.value;
    }
    isRealized() {
        return this.realized;
    }
}

const delayed = (x, t) => new Promise((resolve) => setTimeout(() => resolve(x), t));

const identity = (x) => x;

const ifDef = (f, x) => x != null ? f(x) : undefined;

function juxt(...fns) {
    const [a, b, c, d, e, f, g, h] = fns;
    switch (fns.length) {
        case 1:
            return (x) => [a(x)];
        case 2:
            return (x) => [a(x), b(x)];
        case 3:
            return (x) => [a(x), b(x), c(x)];
        case 4:
            return (x) => [a(x), b(x), c(x), d(x)];
        case 5:
            return (x) => [a(x), b(x), c(x), d(x), e(x)];
        case 6:
            return (x) => [a(x), b(x), c(x), d(x), e(x), f(x)];
        case 7:
            return (x) => [a(x), b(x), c(x), d(x), e(x), f(x), g(x)];
        case 8:
            return (x) => [a(x), b(x), c(x), d(x), e(x), f(x), g(x), h(x)];
        default:
            return (x) => {
                let res = new Array(fns.length);
                for (let i = fns.length; --i >= 0;) {
                    res[i] = fns[i](x);
                }
                return res;
            };
    }
}

function partial(fn, ...args) {
    let [a, b, c, d, e, f, g, h] = args;
    switch (args.length) {
        case 1:
            return (...xs) => fn(a, ...xs);
        case 2:
            return (...xs) => fn(a, b, ...xs);
        case 3:
            return (...xs) => fn(a, b, c, ...xs);
        case 4:
            return (...xs) => fn(a, b, c, d, ...xs);
        case 5:
            return (...xs) => fn(a, b, c, d, e, ...xs);
        case 6:
            return (...xs) => fn(a, b, c, d, e, f, ...xs);
        case 7:
            return (...xs) => fn(a, b, c, d, e, f, g, ...xs);
        case 8:
            return (...xs) => fn(a, b, c, d, e, f, g, h, ...xs);
        default:
            errors.illegalArgs();
    }
}

const promisify = (fn) => new Promise((resolve, reject) => fn((err, result) => (err != null ? reject(err) : resolve(result))));

const threadFirst = (init, ...fns) => fns.reduce((acc, expr) => typeof expr === "function"
    ? expr(acc)
    : expr[0](acc, ...expr.slice(1)), init);

const threadLast = (init, ...fns) => fns.reduce((acc, expr) => typeof expr === "function"
    ? expr(acc)
    : expr[0](...expr.slice(1), acc), init);

const trampoline = (f) => {
    while (typeof f === "function") {
        f = f();
    }
    return f;
};

exports.Delay = Delay;
exports.comp = comp;
exports.compI = compI;
exports.compL = compL;
exports.complement = complement;
exports.constantly = constantly;
exports.delay = delay;
exports.delayed = delayed;
exports.identity = identity;
exports.ifDef = ifDef;
exports.juxt = juxt;
exports.partial = partial;
exports.promisify = promisify;
exports.threadFirst = threadFirst;
exports.threadLast = threadLast;
exports.trampoline = trampoline;
